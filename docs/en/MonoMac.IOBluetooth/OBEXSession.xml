<Type Name="OBEXSession" FullName="MonoMac.IOBluetooth.OBEXSession">
  <TypeSignature Language="C#" Value="public class OBEXSession : MonoMac.Foundation.NSObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OBEXSession extends MonoMac.Foundation.NSObject" />
  <AssemblyInfo>
    <AssemblyName>MonoMac</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>MonoMac.Foundation.NSObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>MonoMac.Foundation.Register("OBEXSession", true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Object representing an OBEX connection to a remote target.</summary>
    <remarks>
      <para>Object representing an OBEX connection to a remote target.</para>
      <para>You will have no need for a obtaining/using a raw OBEXSession, since it requires an underlying transport to do anything useful. However, once you have an object that is a subclass of this class, you can use the functions herein to manipulate that OBEXSession. First off, you will want to use OBEXConnect (if you are a client session) to actually cause the transport to open a connection to a remote target and establish an OBEX connection over it. From there you can issue more commands based on the responses from a server.</para>
      <para>If you are a server session, the first thing you should receive is an OBEXConnect command packet, and you will want to issue an OBEXConnectResponse packet, with your reesponse to that command (success, denied, bad request, etc.).</para>
      <para>You can use the session accessors to access certain information, such as the negotiated max packet length.</para>
      <para>If you wish to implement your own OBEXSession over a transport such as ethernet, you will need to see the end of the file to determine which functions to override, and what to pass to those functions.</para>
      <para>No timeout mechanism has been implemented so far for an OBEXSessions. If you need timeouts, you will need to implement them yourself. This is being explored for a future revision. However, be aware that the OBEX Specification does not explicitly require timeouts, so be sure you allow ample time for commands to complete, as some devices may be slow when sending large amounts of data.</para>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public OBEXSession ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.Foundation.Export("init")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public OBEXSession (MonoMac.Foundation.NSCoder coder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoMac.Foundation.NSCoder coder) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.Foundation.Export("initWithCoder:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="coder" Type="MonoMac.Foundation.NSCoder" />
      </Parameters>
      <Docs>
        <param name="coder">The unarchiver object.</param>
        <summary>A constructor that initializes the object from the data stored in the unarchiver object.</summary>
        <remarks>This constructor is provided to allow the class to be initialized from an unarchiver (for example, during NIB deserialization).</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public OBEXSession (MonoMac.Foundation.NSObjectFlag t);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoMac.Foundation.NSObjectFlag t) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="t" Type="MonoMac.Foundation.NSObjectFlag" />
      </Parameters>
      <Docs>
        <param name="t">Unused sentinel value, pass NSObjectFlag.Empty.</param>
        <summary>Constructor to call on derived classes when the derived class has an [Export] constructor.</summary>
        <remarks>
          <para>This constructor should be called by derived classes when they are initialized using an [Export] attribute. The argument value is ignore, typically the chaining would look like this:</para>
          <example>
            <code lang="C#">
public class MyClass : BaseClass {
    [Export ("initWithFoo:")]
    public MyClass (string foo) : base (NSObjectFlag.Empty)
    {
        ...
    }
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public OBEXSession (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Pointer (handle) to the unmanaged object.</param>
        <summary>A constructor used when creating managed representations of unmanaged objects;  Called by the runtime.</summary>
        <remarks>
          <para>This constructor is invoked by the runtime infrastructure (<see cref="M:MonoMac.ObjCRuntime.GetNSObject (System.IntPtr)" />) to create a new managed representation for a pointer to an unmanaged Objective-C object.    You should not invoke this method directly, instead you should call the GetNSObject method as it will prevent two instances of a managed object to point to the same native object.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public virtual MonoMac.IOBluetooth.OBEXError Abort (IntPtr inOptionalHeaders, UIntPtr inOptionalHeadersLength, MonoMac.ObjCRuntime.Selector inSelector, MonoMac.Foundation.NSObject inTarget, IntPtr inUserRefCon);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype MonoMac.IOBluetooth.OBEXError Abort(native int inOptionalHeaders, native unsigned int inOptionalHeadersLength, class MonoMac.ObjCRuntime.Selector inSelector, class MonoMac.Foundation.NSObject inTarget, native int inUserRefCon) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.Foundation.Export("OBEXAbort:optionalHeadersLength:eventSelector:selectorTarget:refCon:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.OBEXError</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inOptionalHeaders" Type="System.IntPtr" />
        <Parameter Name="inOptionalHeadersLength" Type="System.UIntPtr" />
        <Parameter Name="inSelector" Type="MonoMac.ObjCRuntime.Selector" />
        <Parameter Name="inTarget" Type="MonoMac.Foundation.NSObject" />
        <Parameter Name="inUserRefCon" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="inOptionalHeaders">
          <format type="text/html">
            <dd>
              <para>Can be NULL. Ptr to some data you want to send as your optional headers. Use the provided header contruction kit in OBEX.h and OBEXHeadersToBytes() for convenience.</para>
            </dd>
          </format>
        </param>
        <param name="inOptionalHeadersLength">
          <format type="text/html">
            <dd>
              <para>Length of data in ptr passed in above.</para>
            </dd>
          </format>
        </param>
        <param name="inSelector">
          <format type="text/html">
            <dd>
              <para>A VALID selector to be called when something interesting happens due to this call. Selector in your target object MUST have the following signature, or it will not be called properly (look for error messages in Console.app):</para>
              <para>- (void)OBEXAbortHandler:(const OBEXSessionEvent*)inSessionEvent;</para>
            </dd>
          </format>
        </param>
        <param name="inTarget">
          <format type="text/html">
            <dd>
              <para>A VALID target object for the selector.</para>
            </dd>
          </format>
        </param>
        <param name="inUserRefCon">
          <format type="text/html">
            <dd>
              <para>Whatever you want to pass here. It will be passed back to you in the refCon portion of the OBEXSessionEvent struct. nil is, of course, OK here.</para>
            </dd>
          </format>
        </param>
        <summary>
          <para>Send an OBEX Abort command to the session's target.</para>
        </summary>
        <returns>
        </returns>
        <remarks>
          <para>A NULL selector or target will result in an error. After return, the data passed in will have been sent over the transport. You will receive a response to your command on your selector.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AbortResponse">
      <MemberSignature Language="C#" Value="public virtual MonoMac.IOBluetooth.OBEXError AbortResponse (byte inResponseOpCode, IntPtr inOptionalHeaders, UIntPtr inOptionalHeadersLength, MonoMac.ObjCRuntime.Selector inSelector, MonoMac.Foundation.NSObject inTarget, IntPtr inUserRefCon);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype MonoMac.IOBluetooth.OBEXError AbortResponse(unsigned int8 inResponseOpCode, native int inOptionalHeaders, native unsigned int inOptionalHeadersLength, class MonoMac.ObjCRuntime.Selector inSelector, class MonoMac.Foundation.NSObject inTarget, native int inUserRefCon) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.Foundation.Export("OBEXAbortResponse:optionalHeaders:optionalHeadersLength:eventSelector:selectorTarget:refCon:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.OBEXError</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inResponseOpCode" Type="System.Byte" />
        <Parameter Name="inOptionalHeaders" Type="System.IntPtr" />
        <Parameter Name="inOptionalHeadersLength" Type="System.UIntPtr" />
        <Parameter Name="inSelector" Type="MonoMac.ObjCRuntime.Selector" />
        <Parameter Name="inTarget" Type="MonoMac.Foundation.NSObject" />
        <Parameter Name="inUserRefCon" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="inResponseOpCode">
          <format type="text/html">
            <dd>
              <para>Maximum packet size you want your OBEX session to communicate with. This MUST be lower than the max packet size the client has reported to you in the connect command you received from it.</para>
            </dd>
          </format>
        </param>
        <param name="inOptionalHeaders">
          <format type="text/html">
            <dd>
              <para>Can be NULL. Ptr to some data you want to send as your optional headers. Use the provided header contruction kit in OBEX.h and OBEXHeadersToBytes() for convenience.</para>
            </dd>
          </format>
        </param>
        <param name="inOptionalHeadersLength">
          <format type="text/html">
            <dd>
              <para>Length of data in ptr passed in above.</para>
            </dd>
          </format>
        </param>
        <param name="inSelector">
          <format type="text/html">
            <dd>
              <para>A VALID selector to be called when something interesting happens due to this call. Selector in your target object MUST have the following signature, or it will not be called properly (look for error messages in Console.app):</para>
              <para>- (void)OBEXAbortResponseHandler:(const OBEXSessionEvent*)inSessionEvent;</para>
            </dd>
          </format>
        </param>
        <param name="inTarget">
          <format type="text/html">
            <dd>
              <para>A VALID target object for the selector.</para>
            </dd>
          </format>
        </param>
        <param name="inUserRefCon">
          <format type="text/html">
            <dd>
              <para>Whatever you want to pass here. It will be passed back to you in the refCon portion of the OBEXSessionEvent struct. nil is, of course, OK here.</para>
            </dd>
          </format>
        </param>
        <summary>
          <para>Send a abort response to a session's target.</para>
        </summary>
        <returns>
        </returns>
        <remarks>
          <para>A NULL selector or target will result in an error. After return, the data passed in will have been sent over the underlying OBEX transport. You will receive any responses to your command response on your selector.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClassHandle">
      <MemberSignature Language="C#" Value="public override IntPtr ClassHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ClassHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The handle for this class.</summary>
        <value>The pointer to the Objective-C class.</value>
        <remarks>Each MonoMac class mirrors an unmanaged Objective-C class.   This value contains the pointer to the Objective-C class, it is similar to calling objc_getClass with the object name.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientHandleIncomingData">
      <MemberSignature Language="C#" Value="public virtual void ClientHandleIncomingData (MonoMac.IOBluetooth.OBEXTransportEvent event);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClientHandleIncomingData(valuetype MonoMac.IOBluetooth.OBEXTransportEvent event) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.Foundation.Export("clientHandleIncomingData:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="event" Type="MonoMac.IOBluetooth.OBEXTransportEvent" />
      </Parameters>
      <Docs>
        <param name="event">
          <format type="text/html">
            <dd>
              <para>New event received from the transport.</para>
            </dd>
          </format>
        </param>
        <summary>
          <para>Tranport subclasses need to invoke this from their own data-receive handlers. For example, when data is received over a Bluetooth RFCOMM channel in the IOBluetoothOBEXSession, it in turn calls this to dispatch the data. If you do not handle this case, your server session will not work, guaranteed.</para>
        </summary>
        <remarks>
          <para>Tranport subclasses must call this for OBEX client sessions to work!</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseTransportConnection">
      <MemberSignature Language="C#" Value="public virtual MonoMac.IOBluetooth.OBEXError CloseTransportConnection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype MonoMac.IOBluetooth.OBEXError CloseTransportConnection() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.Foundation.Export("closeTransportConnection")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.OBEXError</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>You must override this - it will be called when the transport connection should be shutdown.</para>
        </summary>
        <returns>
          <para>Return whether or not the transport connection was closed successfully or not. Return OBEXSuccess ( 0 ) on success, otherwise an error code.</para>
        </returns>
        <remarks>
          <para>Tranport subclasses must override this! When called you should take whatever steps are necessary to actually close down the transport connection.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public virtual MonoMac.IOBluetooth.OBEXError Connect (byte inFlags, uint inMaxPacketLength, IntPtr inOptionalHeaders, UIntPtr inOptionalHeadersLength, MonoMac.ObjCRuntime.Selector inSelector, MonoMac.Foundation.NSObject inTarget, IntPtr inUserRefCon);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype MonoMac.IOBluetooth.OBEXError Connect(unsigned int8 inFlags, unsigned int32 inMaxPacketLength, native int inOptionalHeaders, native unsigned int inOptionalHeadersLength, class MonoMac.ObjCRuntime.Selector inSelector, class MonoMac.Foundation.NSObject inTarget, native int inUserRefCon) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.Foundation.Export("OBEXConnect:maxPacketLength:optionalHeaders:optionalHeadersLength:eventSelector:selectorTarget:refCon:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.OBEXError</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inFlags" Type="System.Byte" />
        <Parameter Name="inMaxPacketLength" Type="System.UInt32" />
        <Parameter Name="inOptionalHeaders" Type="System.IntPtr" />
        <Parameter Name="inOptionalHeadersLength" Type="System.UIntPtr" />
        <Parameter Name="inSelector" Type="MonoMac.ObjCRuntime.Selector" />
        <Parameter Name="inTarget" Type="MonoMac.Foundation.NSObject" />
        <Parameter Name="inUserRefCon" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="inFlags">
          <format type="text/html">
            <dd>
              <para>OBEX connect flags. See OBEX.h for possibilities.</para>
            </dd>
          </format>
        </param>
        <param name="inMaxPacketLength">
          <format type="text/html">
            <dd>
              <para>Maximum packet size you want to support. May be negotiated down, depending on target device.</para>
            </dd>
          </format>
        </param>
        <param name="inOptionalHeaders">
          <format type="text/html">
            <dd>
              <para>Can be NULL. Ptr to some data you want to send as your optional headers. Use the provided header contruction kit in OBEX.h and OBEXHeadersToBytes() for convenience.</para>
            </dd>
          </format>
        </param>
        <param name="inOptionalHeadersLength">
          <format type="text/html">
            <dd>
              <para>Length of data in ptr passed in above.</para>
            </dd>
          </format>
        </param>
        <param name="inSelector">
          <format type="text/html">
            <dd>
              <para>A VALID selector to be called when something interesting happens due to this call. Selector in your target object MUST have the following signature, or it will not be called properly (look for error messages in Console.app):</para>
              <para>- (void)OBEXConnectHandler:(const OBEXSessionEvent*)inSessionEvent;</para>
            </dd>
          </format>
        </param>
        <param name="inTarget">
          <format type="text/html">
            <dd>
              <para>A VALID target object for the selector.</para>
            </dd>
          </format>
        </param>
        <param name="inUserRefCon">
          <format type="text/html">
            <dd>
              <para>Whatever you want to pass here. It will be passed back to you in the refCon portion of the OBEXSessionEvent struct. nil is, of course, OK here.</para>
            </dd>
          </format>
        </param>
        <summary>
          <para>Initiate an OBEX connection to a device. Causes underlying transport (Bluetooth, et al) to attempt to connect to a remote device. After success, an OBEX connect packet is sent to establish the OBEX Connection.</para>
        </summary>
        <returns>
        </returns>
        <remarks>
          <para>A NULL selector or target will result in an error. After return, the data passed in will have been sent over the transport. You will receive a response to your command on your selector. If you have already established an OBEX connection and you call this again you will get an 'kOBEXSessionAlreadyConnectedError' as a result.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConnectResponse">
      <MemberSignature Language="C#" Value="public virtual MonoMac.IOBluetooth.OBEXError ConnectResponse (byte inResponseOpCode, byte inFlags, uint inMaxPacketLength, IntPtr inOptionalHeaders, UIntPtr inOptionalHeadersLength, MonoMac.ObjCRuntime.Selector inSelector, MonoMac.Foundation.NSObject inTarget, IntPtr inUserRefCon);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype MonoMac.IOBluetooth.OBEXError ConnectResponse(unsigned int8 inResponseOpCode, unsigned int8 inFlags, unsigned int32 inMaxPacketLength, native int inOptionalHeaders, native unsigned int inOptionalHeadersLength, class MonoMac.ObjCRuntime.Selector inSelector, class MonoMac.Foundation.NSObject inTarget, native int inUserRefCon) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.Foundation.Export("OBEXConnectResponse:flags:maxPacketLength:optionalHeaders:optionalHeadersLength:eventSelector:selectorTarget:refCon:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.OBEXError</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inResponseOpCode" Type="System.Byte" />
        <Parameter Name="inFlags" Type="System.Byte" />
        <Parameter Name="inMaxPacketLength" Type="System.UInt32" />
        <Parameter Name="inOptionalHeaders" Type="System.IntPtr" />
        <Parameter Name="inOptionalHeadersLength" Type="System.UIntPtr" />
        <Parameter Name="inSelector" Type="MonoMac.ObjCRuntime.Selector" />
        <Parameter Name="inTarget" Type="MonoMac.Foundation.NSObject" />
        <Parameter Name="inUserRefCon" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="inResponseOpCode">
          <format type="text/html">
            <dd>
              <para>OBEX connect flags. See OBEX.h for possibilities.</para>
            </dd>
          </format>
        </param>
        <param name="inFlags">
          <format type="text/html">
            <dd>
              <para>OBEX connect constants. See OBEX.h for possibilities.</para>
            </dd>
          </format>
        </param>
        <param name="inMaxPacketLength">
          <format type="text/html">
            <dd>
              <para>Maximum packet size you want your OBEX session to communicate with. This MUST be lower than the max packet size the client has reported to you in the connect command you received from it.</para>
            </dd>
          </format>
        </param>
        <param name="inOptionalHeaders">
          <format type="text/html">
            <dd>
              <para>Can be NULL. Ptr to some data you want to send as your optional headers. Use the provided header contruction kit in OBEX.h and OBEXHeadersToBytes() for convenience.</para>
            </dd>
          </format>
        </param>
        <param name="inOptionalHeadersLength">
          <format type="text/html">
            <dd>
              <para>Length of data in ptr passed in above.</para>
            </dd>
          </format>
        </param>
        <param name="inSelector">
          <format type="text/html">
            <dd>
              <para>A VALID selector to be called when something interesting happens due to this call. Selector in your target object MUST have the following signature, or it will not be called properly (look for error messages in Console.app):</para>
              <para>- (void)OBEXConnectResponseHandler:(const OBEXSessionEvent*)inSessionEvent;</para>
            </dd>
          </format>
        </param>
        <param name="inTarget">
          <format type="text/html">
            <dd>
              <para>A VALID target object for the selector.</para>
            </dd>
          </format>
        </param>
        <param name="inUserRefCon">
          <format type="text/html">
            <dd>
              <para>Whatever you want to pass here. It will be passed back to you in the refCon portion of the OBEXSessionEvent struct. nil is, of course, OK here.</para>
            </dd>
          </format>
        </param>
        <summary>
          <para>Send a connect response to a session's target.</para>
        </summary>
        <returns>
        </returns>
        <remarks>
          <para>A NULL selector or target will result in an error. After return, the data passed in will have been sent over the underlying OBEX transport. You will receive any responses to your command response on your selector.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public virtual MonoMac.IOBluetooth.OBEXError Disconnect (IntPtr inOptionalHeaders, UIntPtr inOptionalHeadersLength, MonoMac.ObjCRuntime.Selector inSelector, MonoMac.Foundation.NSObject inTarget, IntPtr inUserRefCon);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype MonoMac.IOBluetooth.OBEXError Disconnect(native int inOptionalHeaders, native unsigned int inOptionalHeadersLength, class MonoMac.ObjCRuntime.Selector inSelector, class MonoMac.Foundation.NSObject inTarget, native int inUserRefCon) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.Foundation.Export("OBEXDisconnect:optionalHeadersLength:eventSelector:selectorTarget:refCon:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.OBEXError</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inOptionalHeaders" Type="System.IntPtr" />
        <Parameter Name="inOptionalHeadersLength" Type="System.UIntPtr" />
        <Parameter Name="inSelector" Type="MonoMac.ObjCRuntime.Selector" />
        <Parameter Name="inTarget" Type="MonoMac.Foundation.NSObject" />
        <Parameter Name="inUserRefCon" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="inOptionalHeaders">
          <format type="text/html">
            <dd>
              <para>Can be NULL. Ptr to some data you want to send as your optional headers. Use the provided header contruction kit in OBEX.h and OBEXHeadersToBytes() for convenience.</para>
            </dd>
          </format>
        </param>
        <param name="inOptionalHeadersLength">
          <format type="text/html">
            <dd>
              <para>Length of data in ptr passed in above.</para>
            </dd>
          </format>
        </param>
        <param name="inSelector">
          <format type="text/html">
            <dd>
              <para>A VALID selector to be called when something interesting happens due to this call. Selector in your target object MUST have the following signature, or it will not be called properly (look for error messages in Console.app):</para>
              <para>- (void)OBEXDisconnectHandler:(const OBEXSessionEvent*)inSessionEvent;</para>
            </dd>
          </format>
        </param>
        <param name="inTarget">
          <format type="text/html">
            <dd>
              <para>A VALID target object for the selector.</para>
            </dd>
          </format>
        </param>
        <param name="inUserRefCon">
          <format type="text/html">
            <dd>
              <para>Whatever you want to pass here. It will be passed back to you in the refCon portion of the OBEXSessionEvent struct. nil is, of course, OK here.</para>
            </dd>
          </format>
        </param>
        <summary>
          <para>Send an OBEX Disconnect command to the session's target. THIS DOES NOT necessarily close the underlying transport connection. Deleting the session will ensure that closure.</para>
        </summary>
        <returns>
        </returns>
        <remarks>
          <para>A NULL selector or target will result in an error. After return, the data passed in will have been sent over the transport. You will receive a response to your command on your selector. Be careful not to exceed the max packet length in your optional headers, or your command will be rejected. It is recommended that you call getMaxPacketLength on your session before issuing this command so you know how much data the session's target will accept in a single transaction.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisconnectResponse">
      <MemberSignature Language="C#" Value="public virtual MonoMac.IOBluetooth.OBEXError DisconnectResponse (byte inResponseOpCode, IntPtr inOptionalHeaders, UIntPtr inOptionalHeadersLength, MonoMac.ObjCRuntime.Selector inSelector, MonoMac.Foundation.NSObject inTarget, IntPtr inUserRefCon);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype MonoMac.IOBluetooth.OBEXError DisconnectResponse(unsigned int8 inResponseOpCode, native int inOptionalHeaders, native unsigned int inOptionalHeadersLength, class MonoMac.ObjCRuntime.Selector inSelector, class MonoMac.Foundation.NSObject inTarget, native int inUserRefCon) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.Foundation.Export("OBEXDisconnectResponse:optionalHeaders:optionalHeadersLength:eventSelector:selectorTarget:refCon:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.OBEXError</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inResponseOpCode" Type="System.Byte" />
        <Parameter Name="inOptionalHeaders" Type="System.IntPtr" />
        <Parameter Name="inOptionalHeadersLength" Type="System.UIntPtr" />
        <Parameter Name="inSelector" Type="MonoMac.ObjCRuntime.Selector" />
        <Parameter Name="inTarget" Type="MonoMac.Foundation.NSObject" />
        <Parameter Name="inUserRefCon" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="inResponseOpCode">
          <format type="text/html">
            <dd>
              <para>Maximum packet size you want your OBEX session to communicate with. This MUST be lower than the max packet size the client has reported to you in the connect command you received from it.</para>
            </dd>
          </format>
        </param>
        <param name="inOptionalHeaders">
          <format type="text/html">
            <dd>
              <para>Can be NULL. Ptr to some data you want to send as your optional headers. Use the provided header contruction kit in OBEX.h and OBEXHeadersToBytes() for convenience.</para>
            </dd>
          </format>
        </param>
        <param name="inOptionalHeadersLength">
          <format type="text/html">
            <dd>
              <para>Length of data in ptr passed in above.</para>
            </dd>
          </format>
        </param>
        <param name="inSelector">
          <format type="text/html">
            <dd>
              <para>A VALID selector to be called when something interesting happens due to this call. Selector in your target object MUST have the following signature, or it will not be called properly (look for error messages in Console.app):</para>
              <para>- (void)OBEXDisconnectResponseHandler:(const OBEXSessionEvent*)inSessionEvent;</para>
            </dd>
          </format>
        </param>
        <param name="inTarget">
          <format type="text/html">
            <dd>
              <para>A VALID target object for the selector.</para>
            </dd>
          </format>
        </param>
        <param name="inUserRefCon">
          <format type="text/html">
            <dd>
              <para>Whatever you want to pass here. It will be passed back to you in the refCon portion of the OBEXSessionEvent struct. nil is, of course, OK here.</para>
            </dd>
          </format>
        </param>
        <summary>
          <para>Send a disconnect response to a session's target.</para>
        </summary>
        <returns>
        </returns>
        <remarks>
          <para>A NULL selector or target will result in an error. After return, the data passed in will have been sent over the underlying OBEX transport. You will receive any responses to your command response on your selector.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Get">
      <MemberSignature Language="C#" Value="public virtual MonoMac.IOBluetooth.OBEXError Get (bool isFinalChunk, IntPtr inHeaders, UIntPtr inHeadersLength, MonoMac.ObjCRuntime.Selector inSelector, MonoMac.Foundation.NSObject inTarget, IntPtr inUserRefCon);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype MonoMac.IOBluetooth.OBEXError Get(bool isFinalChunk, native int inHeaders, native unsigned int inHeadersLength, class MonoMac.ObjCRuntime.Selector inSelector, class MonoMac.Foundation.NSObject inTarget, native int inUserRefCon) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.Foundation.Export("OBEXGet:headers:headersLength:eventSelector:selectorTarget:refCon:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.OBEXError</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isFinalChunk" Type="System.Boolean" />
        <Parameter Name="inHeaders" Type="System.IntPtr" />
        <Parameter Name="inHeadersLength" Type="System.UIntPtr" />
        <Parameter Name="inSelector" Type="MonoMac.ObjCRuntime.Selector" />
        <Parameter Name="inTarget" Type="MonoMac.Foundation.NSObject" />
        <Parameter Name="inUserRefCon" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="isFinalChunk">
          <format type="text/html">
            <dd>
              <para>Specify if this request is complete in one shot - that all the headers you are supplying will fit in the negotiated max packet length.</para>
            </dd>
          </format>
        </param>
        <param name="inHeaders">
          <format type="text/html">
            <dd>
              <para>Can be NULL. Ptr to some data you want to send as your headers, such as Length, Name, etc. Use the provided header contruction kit in OBEX.h and OBEXHeadersToBytes() for your convenience.</para>
            </dd>
          </format>
        </param>
        <param name="inHeadersLength">
          <format type="text/html">
            <dd>
              <para>Length of data in ptr passed in above.</para>
            </dd>
          </format>
        </param>
        <param name="inSelector">
          <format type="text/html">
            <dd>
              <para>A VALID selector to be called when something interesting happens due to this call. Selector in your target object MUST have the following signature, or it will not be called properly (look for error messages in Console.app):</para>
              <para>- (void)OBEXGetHandler:(const OBEXSessionEvent*)inSessionEvent;</para>
            </dd>
          </format>
        </param>
        <param name="inTarget">
          <format type="text/html">
            <dd>
              <para>A VALID target object for the selector.</para>
            </dd>
          </format>
        </param>
        <param name="inUserRefCon">
          <format type="text/html">
            <dd>
              <para>Whatever you want to pass here. It will be passed back to you in the refCon portion of the OBEXSessionEvent struct. nil is, of course, OK here.</para>
            </dd>
          </format>
        </param>
        <summary>
          <para>Send an OBEX Get command to the session's target.</para>
        </summary>
        <returns>
        </returns>
        <remarks>
          <para>A NULL selector or target will result in an error. After return, the data passed in will have been sent over the transport. You will receive a response to your command on your selector.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAvailableCommandPayloadLength">
      <MemberSignature Language="C#" Value="public virtual uint GetAvailableCommandPayloadLength (byte inOpCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int32 GetAvailableCommandPayloadLength(unsigned int8 inOpCode) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.Foundation.Export("getAvailableCommandPayloadLength:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inOpCode" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="inOpCode">
          <format type="text/html">
            <dd>
              <para>The opcode you are interested in sending (as a client).</para>
            </dd>
          </format>
        </param>
        <summary>
          <para>Determine the maximum amount of data you can send in a particular command as an OBEX client session.</para>
        </summary>
        <returns>
          <para>The maximum amount of data a particular packet can handle, after accounting for any command overhead.</para>
        </returns>
        <remarks>
          <para>Each OBEX Command has a certain amount of overhead. Since the negotiated max packet length does not indicate what the maximum data amount you can send in a particular command's packet, you can use this function to determine how much data to provide in optional headers or body data headers.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAvailableCommandResponsePayloadLength">
      <MemberSignature Language="C#" Value="public virtual uint GetAvailableCommandResponsePayloadLength (byte inOpCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int32 GetAvailableCommandResponsePayloadLength(unsigned int8 inOpCode) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.Foundation.Export("getAvailableCommandResponsePayloadLength:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inOpCode" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="inOpCode">
          <format type="text/html">
            <dd>
              <para>The opcode you are interested in responding to (as a server).</para>
            </dd>
          </format>
        </param>
        <summary>
          <para>Determine the maximum amount of data you can send in a particular command response as an OBEX server session.</para>
        </summary>
        <returns>
          <para>The maximum amount of data a particular packet can handle, after accounting for any command response overhead.</para>
        </returns>
        <remarks>
          <para>Each OBEX Command response has a certain amount of overhead. Since the negotiated max packet length does not indicate what the maximum data amount you can send in a particular response's packet, you can use this function to determine how much data to provide in optional headers or body data headers.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetResponse">
      <MemberSignature Language="C#" Value="public virtual MonoMac.IOBluetooth.OBEXError GetResponse (byte inResponseOpCode, IntPtr inOptionalHeaders, UIntPtr inOptionalHeadersLength, MonoMac.ObjCRuntime.Selector inSelector, MonoMac.Foundation.NSObject inTarget, IntPtr inUserRefCon);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype MonoMac.IOBluetooth.OBEXError GetResponse(unsigned int8 inResponseOpCode, native int inOptionalHeaders, native unsigned int inOptionalHeadersLength, class MonoMac.ObjCRuntime.Selector inSelector, class MonoMac.Foundation.NSObject inTarget, native int inUserRefCon) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.Foundation.Export("OBEXGetResponse:optionalHeaders:optionalHeadersLength:eventSelector:selectorTarget:refCon:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.OBEXError</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inResponseOpCode" Type="System.Byte" />
        <Parameter Name="inOptionalHeaders" Type="System.IntPtr" />
        <Parameter Name="inOptionalHeadersLength" Type="System.UIntPtr" />
        <Parameter Name="inSelector" Type="MonoMac.ObjCRuntime.Selector" />
        <Parameter Name="inTarget" Type="MonoMac.Foundation.NSObject" />
        <Parameter Name="inUserRefCon" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="inResponseOpCode">
          <format type="text/html">
            <dd>
              <para>Maximum packet size you want your OBEX session to communicate with. This MUST be lower than the max packet size the client has reported to you in the connect command you received from it.</para>
            </dd>
          </format>
        </param>
        <param name="inOptionalHeaders">
          <format type="text/html">
            <dd>
              <para>Can be NULL. Ptr to some data you want to send as your optional headers. Use the provided header contruction kit in OBEX.h and OBEXHeadersToBytes() for convenience.</para>
            </dd>
          </format>
        </param>
        <param name="inOptionalHeadersLength">
          <format type="text/html">
            <dd>
              <para>Length of data in ptr passed in above.</para>
            </dd>
          </format>
        </param>
        <param name="inSelector">
          <format type="text/html">
            <dd>
              <para>A VALID selector to be called when something interesting happens due to this call. Selector in your target object MUST have the following signature, or it will not be called properly (look for error messages in Console.app):</para>
              <para>- (void)OBEXGetResponseHandler:(const OBEXSessionEvent*)inSessionEvent;</para>
            </dd>
          </format>
        </param>
        <param name="inTarget">
          <format type="text/html">
            <dd>
              <para>A VALID target object for the selector.</para>
            </dd>
          </format>
        </param>
        <param name="inUserRefCon">
          <format type="text/html">
            <dd>
              <para>Whatever you want to pass here. It will be passed back to you in the refCon portion of the OBEXSessionEvent struct. nil is, of course, OK here.</para>
            </dd>
          </format>
        </param>
        <summary>
          <para>Send a get response to a session's target.</para>
        </summary>
        <returns>
        </returns>
        <remarks>
          <para>A NULL selector or target will result in an error. After return, the data passed in will have been sent over the underlying OBEX transport. You will receive any responses to your command response on your selector.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasOpenConnection">
      <MemberSignature Language="C#" Value="public virtual bool HasOpenConnection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasOpenConnection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoMac.Foundation.Export("hasOpenOBEXConnection")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <para>Has a successful connect packet been sent and received? This API tells you so.</para>
        </summary>
        <value>
        </value>
        <remarks>
          <para>A "transport" connection may exist (such as a Bluetooth baseband connection), but the OBEX connection may not be established over that transport. If it has been, this function returns true.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasOpenTransportConnection">
      <MemberSignature Language="C#" Value="public virtual bool HasOpenTransportConnection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasOpenTransportConnection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoMac.Foundation.Export("hasOpenTransportConnection")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <para>You must override this - it will be called periodically to determine if a transport connection is open or not.</para>
        </summary>
        <value>
        </value>
        <remarks>
          <para>Tranport subclasses must override this! When called you simply return if the transport connection is still open or not.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxPacketLength">
      <MemberSignature Language="C#" Value="public virtual uint MaxPacketLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int32 MaxPacketLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoMac.Foundation.Export("getMaxPacketLength")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <para>Gets current max packet length.</para>
        </summary>
        <value>
        </value>
        <remarks>
          <para>This value *could* change before and after a connect command has been sent or a connect command response has been received, since the recipient could negotiate a lower max packet size.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenTransportConnection">
      <MemberSignature Language="C#" Value="public virtual MonoMac.IOBluetooth.OBEXError OpenTransportConnection (MonoMac.ObjCRuntime.Selector inSelector, MonoMac.Foundation.NSObject inTarget, IntPtr inUserRefCon);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype MonoMac.IOBluetooth.OBEXError OpenTransportConnection(class MonoMac.ObjCRuntime.Selector inSelector, class MonoMac.Foundation.NSObject inTarget, native int inUserRefCon) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.Foundation.Export("openTransportConnection:selectorTarget:refCon:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.OBEXError</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inSelector" Type="MonoMac.ObjCRuntime.Selector" />
        <Parameter Name="inTarget" Type="MonoMac.Foundation.NSObject" />
        <Parameter Name="inUserRefCon" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="inSelector">
          <format type="text/html">
            <dd>
              <para>Selector to call for success, failure or timeout.</para>
            </dd>
          </format>
        </param>
        <param name="inTarget">
          <format type="text/html">
            <dd>
              <para>Target on which to call the selector.</para>
            </dd>
          </format>
        </param>
        <param name="inUserRefCon">
          <format type="text/html">
            <dd>
              <para>Caller's reference constant.</para>
            </dd>
          </format>
        </param>
        <summary>
          <para>Opens a transport connection to a device. A Bluetooth connection is one example of a transport.</para>
        </summary>
        <returns>
        </returns>
        <remarks>
          <para>Tranport subclasses must override this! when called you should attempt to open your transport connection, and if you are successful, return kOBEXSuccess, otherwise an interesting error code.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Put">
      <MemberSignature Language="C#" Value="public virtual MonoMac.IOBluetooth.OBEXError Put (bool isFinalChunk, IntPtr inHeadersData, UIntPtr inHeadersDataLength, IntPtr inBodyData, UIntPtr inBodyDataLength, MonoMac.ObjCRuntime.Selector inSelector, MonoMac.Foundation.NSObject inTarget, IntPtr inUserRefCon);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype MonoMac.IOBluetooth.OBEXError Put(bool isFinalChunk, native int inHeadersData, native unsigned int inHeadersDataLength, native int inBodyData, native unsigned int inBodyDataLength, class MonoMac.ObjCRuntime.Selector inSelector, class MonoMac.Foundation.NSObject inTarget, native int inUserRefCon) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.Foundation.Export("OBEXPut:headersData:headersDataLength:bodyData:bodyDataLength:eventSelector:selectorTarget:refCon:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.OBEXError</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isFinalChunk" Type="System.Boolean" />
        <Parameter Name="inHeadersData" Type="System.IntPtr" />
        <Parameter Name="inHeadersDataLength" Type="System.UIntPtr" />
        <Parameter Name="inBodyData" Type="System.IntPtr" />
        <Parameter Name="inBodyDataLength" Type="System.UIntPtr" />
        <Parameter Name="inSelector" Type="MonoMac.ObjCRuntime.Selector" />
        <Parameter Name="inTarget" Type="MonoMac.Foundation.NSObject" />
        <Parameter Name="inUserRefCon" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="isFinalChunk">
          <format type="text/html">
            <dd>
              <para>Specify if this request is complete in one shot - that all the headers you are supplying will fit in the negotiated max packet length.</para>
            </dd>
          </format>
        </param>
        <param name="inHeadersData">
          <format type="text/html">
            <dd>
              <para>Can be NULL. Ptr to some data you want to send as your headers, such as Length, Name, etc. Use the provided header contruction kit in OBEX.h and OBEXHeadersToBytes() for convenience.</para>
            </dd>
          </format>
        </param>
        <param name="inHeadersDataLength">
          <format type="text/html">
            <dd>
              <para>Length of data in ptr passed in above.</para>
            </dd>
          </format>
        </param>
        <param name="inBodyData">
          <format type="text/html">
            <dd>
              <para>Can be NULL. Ptr to some data you want to send as your BODY header. Do not construct a real OBEX header here, it will be done for you - just pass a pointer to your data, we'll do the rest. HOWEVER, be aware that some overhead (3 bytes) will be added to the data in constructing the BODY header for you.</para>
            </dd>
          </format>
        </param>
        <param name="inBodyDataLength">
          <format type="text/html">
            <dd>
              <para>Length of data in ptr passed in above.</para>
            </dd>
          </format>
        </param>
        <param name="inSelector">
          <format type="text/html">
            <dd>
              <para>A VALID selector to be called when something interesting happens due to this call. Selector in your target object MUST have the following signature, or it will not be called properly (look for error messages in Console.app):</para>
              <para>- (void)OBEXPutHandler:(const OBEXSessionEvent*)inSessionEvent;</para>
            </dd>
          </format>
        </param>
        <param name="inTarget">
          <format type="text/html">
            <dd>
              <para>A VALID target object for the selector.</para>
            </dd>
          </format>
        </param>
        <param name="inUserRefCon">
          <format type="text/html">
            <dd>
              <para>Whatever you want to pass here. It will be passed back to you in the refCon portion of the OBEXSessionEvent struct. nil is, of course, OK here.</para>
            </dd>
          </format>
        </param>
        <summary>
          <para>Send an OBEX Put command to the session's target.</para>
        </summary>
        <returns>
        </returns>
        <remarks>
          <para>A NULL selector or target will result in an error. After return, the data passed in will have been sent over the transport. You will receive a response to your command on your selector.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PutResponse">
      <MemberSignature Language="C#" Value="public virtual MonoMac.IOBluetooth.OBEXError PutResponse (byte inResponseOpCode, IntPtr inOptionalHeaders, UIntPtr inOptionalHeadersLength, MonoMac.ObjCRuntime.Selector inSelector, MonoMac.Foundation.NSObject inTarget, IntPtr inUserRefCon);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype MonoMac.IOBluetooth.OBEXError PutResponse(unsigned int8 inResponseOpCode, native int inOptionalHeaders, native unsigned int inOptionalHeadersLength, class MonoMac.ObjCRuntime.Selector inSelector, class MonoMac.Foundation.NSObject inTarget, native int inUserRefCon) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.Foundation.Export("OBEXPutResponse:optionalHeaders:optionalHeadersLength:eventSelector:selectorTarget:refCon:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.OBEXError</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inResponseOpCode" Type="System.Byte" />
        <Parameter Name="inOptionalHeaders" Type="System.IntPtr" />
        <Parameter Name="inOptionalHeadersLength" Type="System.UIntPtr" />
        <Parameter Name="inSelector" Type="MonoMac.ObjCRuntime.Selector" />
        <Parameter Name="inTarget" Type="MonoMac.Foundation.NSObject" />
        <Parameter Name="inUserRefCon" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="inResponseOpCode">
          <format type="text/html">
            <dd>
              <para>Maximum packet size you want your OBEX session to communicate with. This MUST be lower than the max packet size the client has reported to you in the connect command you received from it.</para>
            </dd>
          </format>
        </param>
        <param name="inOptionalHeaders">
          <format type="text/html">
            <dd>
              <para>Can be NULL. Ptr to some data you want to send as your optional headers. Use the provided header contruction kit in OBEX.h and OBEXHeadersToBytes() for convenience.</para>
            </dd>
          </format>
        </param>
        <param name="inOptionalHeadersLength">
          <format type="text/html">
            <dd>
              <para>Length of data in ptr passed in above.</para>
            </dd>
          </format>
        </param>
        <param name="inSelector">
          <format type="text/html">
            <dd>
              <para>A VALID selector to be called when something interesting happens due to this call. Selector in your target object MUST have the following signature, or it will not be called properly (look for error messages in Console.app):</para>
              <para>- (void)OBEXPutResponseHandler:(const OBEXSessionEvent*)inSessionEvent;</para>
            </dd>
          </format>
        </param>
        <param name="inTarget">
          <format type="text/html">
            <dd>
              <para>A VALID target object for the selector.</para>
            </dd>
          </format>
        </param>
        <param name="inUserRefCon">
          <format type="text/html">
            <dd>
              <para>Whatever you want to pass here. It will be passed back to you in the refCon portion of the OBEXSessionEvent struct. nil is, of course, OK here.</para>
            </dd>
          </format>
        </param>
        <summary>
          <para>Send a put response to a session's target.</para>
        </summary>
        <returns>
        </returns>
        <remarks>
          <para>A NULL selector or target will result in an error. After return, the data passed in will have been sent over the underlying OBEX transport. You will receive any responses to your command response on your selector.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SendDataToTransport">
      <MemberSignature Language="C#" Value="public virtual MonoMac.IOBluetooth.OBEXError SendDataToTransport (IntPtr inDataToSend, UIntPtr inDataLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype MonoMac.IOBluetooth.OBEXError SendDataToTransport(native int inDataToSend, native unsigned int inDataLength) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.Foundation.Export("sendDataToTransport:dataLength:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.OBEXError</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inDataToSend" Type="System.IntPtr" />
        <Parameter Name="inDataLength" Type="System.UIntPtr" />
      </Parameters>
      <Docs>
        <param name="inDataToSend">
          <format type="text/html">
            <dd>
              <para>Data to shove over the transport to a remote OBEX session.</para>
            </dd>
          </format>
        </param>
        <param name="inDataLength">
          <format type="text/html">
            <dd>
              <para>Length of data passed in.</para>
            </dd>
          </format>
        </param>
        <summary>
          <para>You must override this to send data over your transport. This does nothing by default, it will return a kOBEXUnsupportedError.</para>
        </summary>
        <returns>
        </returns>
        <remarks>
          <para>Tranport subclasses must override this! When called you should send the data over the transport to the remote session.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ServerHandleIncomingData">
      <MemberSignature Language="C#" Value="public virtual void ServerHandleIncomingData (MonoMac.IOBluetooth.OBEXTransportEvent event);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ServerHandleIncomingData(valuetype MonoMac.IOBluetooth.OBEXTransportEvent event) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.Foundation.Export("serverHandleIncomingData:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="event" Type="MonoMac.IOBluetooth.OBEXTransportEvent" />
      </Parameters>
      <Docs>
        <param name="event">
          <format type="text/html">
            <dd>
              <para>New event received from the transport.</para>
            </dd>
          </format>
        </param>
        <summary>
          <para>Tranport subclasses need to invoke this from their own data-receive handlers. For example, when data is received over a Bluetooth RFCOMM channel in the IOBluetoothOBEXSession, it in turn calls this to dispatch the data. If you do not handle this case, your server session will not work, guaranteed.</para>
        </summary>
        <remarks>
          <para>Tranport subclasses must call this for OBEX server sessions to work!</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetEventCallback">
      <MemberSignature Language="C#" Value="public virtual void SetEventCallback (MonoMac.IOBluetooth.OBEXSessionEventCallback inEventCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetEventCallback(class MonoMac.IOBluetooth.OBEXSessionEventCallback inEventCallback) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.Foundation.Export("setEventCallback:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inEventCallback" Type="MonoMac.IOBluetooth.OBEXSessionEventCallback" />
      </Parameters>
      <Docs>
        <param name="inEventCallback">
          <format type="text/html">
            <dd>
              <para>Function to callback. Should be non-NULL, unless you are attempting to clear the callback, but doing that doesn't make much sense.</para>
            </dd>
          </format>
        </param>
        <summary>
          <para>Sets the C-API callback used when the session recieves data.</para>
        </summary>
        <remarks>
          <para>This is really not intended for client sessions. Only subclasses would really be interested in using this. They should set these when their subclass object is created, because otherwise they will have no way of receiving the initial command data packet. This is a partner to setEventRefCon, described below.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetEventRefCon">
      <MemberSignature Language="C#" Value="public virtual void SetEventRefCon (IntPtr inRefCon);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetEventRefCon(native int inRefCon) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.Foundation.Export("setEventRefCon:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inRefCon" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="inRefCon">
          <format type="text/html">
            <dd>
              <para>User's refCon that will get passed when their event callback is invoked.</para>
            </dd>
          </format>
        </param>
        <summary>
          <para>Sets the C-API callback refCon used when the session recieves data.</para>
        </summary>
        <remarks>
          <para>This is really not intended for client sessions. Only subclasses would really be interested in using this. They should set these when their subclass object is created, because otherwise they will have no context in their callback.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetEventSelector">
      <MemberSignature Language="C#" Value="public virtual void SetEventSelector (MonoMac.ObjCRuntime.Selector inEventSelector, MonoMac.Foundation.NSObject inEventSelectorTarget, MonoMac.Foundation.NSObject inUserRefCon);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetEventSelector(class MonoMac.ObjCRuntime.Selector inEventSelector, class MonoMac.Foundation.NSObject inEventSelectorTarget, class MonoMac.Foundation.NSObject inUserRefCon) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.Foundation.Export("setEventSelector:target:refCon:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inEventSelector" Type="MonoMac.ObjCRuntime.Selector" />
        <Parameter Name="inEventSelectorTarget" Type="MonoMac.Foundation.NSObject" />
        <Parameter Name="inUserRefCon" Type="MonoMac.Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="inEventSelector">
          <format type="text/html">
            <dd>
              <para>Selector to call on the target.</para>
            </dd>
          </format>
        </param>
        <param name="inEventSelectorTarget">
          <format type="text/html">
            <dd>
              <para>Target to be called with the selector.</para>
            </dd>
          </format>
        </param>
        <param name="inUserRefCon">
          <format type="text/html">
            <dd>
              <para>User's refCon that will get passed when their event callback is invoked.</para>
            </dd>
          </format>
        </param>
        <summary>
          <para>Allow you to set a selector to be called when events occur on the OBEX session.</para>
        </summary>
        <remarks>
          <para>Really not needed to be used, since the event selector will get set when an OBEX command is sent out.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPath">
      <MemberSignature Language="C#" Value="public virtual MonoMac.IOBluetooth.OBEXError SetPath (byte inFlags, byte inConstants, IntPtr inOptionalHeaders, UIntPtr inOptionalHeadersLength, MonoMac.ObjCRuntime.Selector inSelector, MonoMac.Foundation.NSObject inTarget, IntPtr inUserRefCon);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype MonoMac.IOBluetooth.OBEXError SetPath(unsigned int8 inFlags, unsigned int8 inConstants, native int inOptionalHeaders, native unsigned int inOptionalHeadersLength, class MonoMac.ObjCRuntime.Selector inSelector, class MonoMac.Foundation.NSObject inTarget, native int inUserRefCon) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.Foundation.Export("OBEXSetPath:constants:optionalHeaders:optionalHeadersLength:eventSelector:selectorTarget:refCon:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.OBEXError</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inFlags" Type="System.Byte" />
        <Parameter Name="inConstants" Type="System.Byte" />
        <Parameter Name="inOptionalHeaders" Type="System.IntPtr" />
        <Parameter Name="inOptionalHeadersLength" Type="System.UIntPtr" />
        <Parameter Name="inSelector" Type="MonoMac.ObjCRuntime.Selector" />
        <Parameter Name="inTarget" Type="MonoMac.Foundation.NSObject" />
        <Parameter Name="inUserRefCon" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="inFlags">
          <format type="text/html">
            <dd>
              <para>OBEX setpath flags. See OBEX.h for possibilities.</para>
            </dd>
          </format>
        </param>
        <param name="inConstants">
          <format type="text/html">
            <dd>
              <para>OBEX setpath constants. See OBEX.h for possibilities.</para>
            </dd>
          </format>
        </param>
        <param name="inOptionalHeaders">
          <format type="text/html">
            <dd>
              <para>Can be NULL. Ptr to some data you want to send as your optional headers. Use the provided header contruction kit in OBEX.h and OBEXHeadersToBytes() for convenience.</para>
            </dd>
          </format>
        </param>
        <param name="inOptionalHeadersLength">
          <format type="text/html">
            <dd>
              <para>Length of data in ptr passed in above.</para>
            </dd>
          </format>
        </param>
        <param name="inSelector">
          <format type="text/html">
            <dd>
              <para>A VALID selector to be called when something interesting happens due to this call. Selector in your target object MUST have the following signature, or it will not be called properly (look for error messages in Console.app):</para>
              <para>- (void)OBEXSetPathHandler:(const OBEXSessionEvent*)inSessionEvent;</para>
            </dd>
          </format>
        </param>
        <param name="inTarget">
          <format type="text/html">
            <dd>
              <para>A VALID target object for the selector.</para>
            </dd>
          </format>
        </param>
        <param name="inUserRefCon">
          <format type="text/html">
            <dd>
              <para>Whatever you want to pass here. It will be passed back to you in the refCon portion of the OBEXSessionEvent struct. nil is, of course, OK here.</para>
            </dd>
          </format>
        </param>
        <summary>
          <para>Send an OBEX SetPath command to the session's target.</para>
        </summary>
        <returns>
        </returns>
        <remarks>
          <para>A NULL selector or target will result in an error. After return, the data passed in will have been sent over the transport. You will receive a response to your command on your selector.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPathResponse">
      <MemberSignature Language="C#" Value="public virtual MonoMac.IOBluetooth.OBEXError SetPathResponse (byte inResponseOpCode, IntPtr inOptionalHeaders, UIntPtr inOptionalHeadersLength, MonoMac.ObjCRuntime.Selector inSelector, MonoMac.Foundation.NSObject inTarget, IntPtr inUserRefCon);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype MonoMac.IOBluetooth.OBEXError SetPathResponse(unsigned int8 inResponseOpCode, native int inOptionalHeaders, native unsigned int inOptionalHeadersLength, class MonoMac.ObjCRuntime.Selector inSelector, class MonoMac.Foundation.NSObject inTarget, native int inUserRefCon) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.Foundation.Export("OBEXSetPathResponse:optionalHeaders:optionalHeadersLength:eventSelector:selectorTarget:refCon:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.OBEXError</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inResponseOpCode" Type="System.Byte" />
        <Parameter Name="inOptionalHeaders" Type="System.IntPtr" />
        <Parameter Name="inOptionalHeadersLength" Type="System.UIntPtr" />
        <Parameter Name="inSelector" Type="MonoMac.ObjCRuntime.Selector" />
        <Parameter Name="inTarget" Type="MonoMac.Foundation.NSObject" />
        <Parameter Name="inUserRefCon" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="inResponseOpCode">
          <format type="text/html">
            <dd>
              <para>Maximum packet size you want your OBEX session to communicate with. This MUST be lower than the max packet size the client has reported to you in the connect command you received from it.</para>
            </dd>
          </format>
        </param>
        <param name="inOptionalHeaders">
          <format type="text/html">
            <dd>
              <para>Can be NULL. Ptr to some data you want to send as your optional headers. Use the provided header contruction kit in OBEX.h and OBEXHeadersToBytes() for convenience.</para>
            </dd>
          </format>
        </param>
        <param name="inOptionalHeadersLength">
          <format type="text/html">
            <dd>
              <para>Length of data in ptr passed in above.</para>
            </dd>
          </format>
        </param>
        <param name="inSelector">
          <format type="text/html">
            <dd>
              <para>A VALID selector to be called when something interesting happens due to this call. Selector in your target object MUST have the following signature, or it will not be called properly (look for error messages in Console.app):</para>
              <para>- (void)OBEXSetPathResponseHandler:(const OBEXSessionEvent*)inSessionEvent;</para>
            </dd>
          </format>
        </param>
        <param name="inTarget">
          <format type="text/html">
            <dd>
              <para>A VALID target object for the selector.</para>
            </dd>
          </format>
        </param>
        <param name="inUserRefCon">
          <format type="text/html">
            <dd>
              <para>Whatever you want to pass here. It will be passed back to you in the refCon portion of the OBEXSessionEvent struct. nil is, of course, OK here.</para>
            </dd>
          </format>
        </param>
        <summary>
          <para>Send a set path response to a session's target.</para>
        </summary>
        <returns>
        </returns>
        <remarks>
          <para>A NULL selector or target will result in an error. After return, the data passed in will have been sent over the underlying OBEX transport. You will receive any responses to your command response on your selector.</para>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
