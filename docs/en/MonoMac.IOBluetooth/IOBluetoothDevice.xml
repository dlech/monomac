<Type Name="IOBluetoothDevice" FullName="MonoMac.IOBluetooth.IOBluetoothDevice">
  <TypeSignature Language="C#" Value="public class IOBluetoothDevice : MonoMac.IOBluetooth.IOBluetoothObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi IOBluetoothDevice extends MonoMac.IOBluetooth.IOBluetoothObject" />
  <AssemblyInfo>
    <AssemblyName>MonoMac</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>MonoMac.IOBluetooth.IOBluetoothObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>MonoMac.Foundation.Register("IOBluetoothDevice", true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>An instance of IOBluetoothDevice represents a single remote Bluetooth device.</summary>
    <remarks>An IOBluetoothDevice object may exist independent of the existence of a baseband connection with the target device. Through this object you can request baseband connections to be made, request opening and closing of L2CAP and RFCOMM channels.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IOBluetoothDevice ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.Foundation.Export("init")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IOBluetoothDevice (MonoMac.Foundation.NSCoder coder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoMac.Foundation.NSCoder coder) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.Foundation.Export("initWithCoder:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="coder" Type="MonoMac.Foundation.NSCoder" />
      </Parameters>
      <Docs>
        <param name="coder">The unarchiver object.</param>
        <summary>A constructor that initializes the object from the data stored in the unarchiver object.</summary>
        <remarks>This constructor is provided to allow the class to be initialized from an unarchiver (for example, during NIB deserialization).</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IOBluetoothDevice (MonoMac.Foundation.NSObjectFlag t);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoMac.Foundation.NSObjectFlag t) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="t" Type="MonoMac.Foundation.NSObjectFlag" />
      </Parameters>
      <Docs>
        <param name="t">Unused sentinel value, pass NSObjectFlag.Empty.</param>
        <summary>Constructor to call on derived classes when the derived class has an [Export] constructor.</summary>
        <remarks>
          <para>This constructor should be called by derived classes when they are initialized using an [Export] attribute. The argument value is ignore, typically the chaining would look like this:</para>
          <example>
            <code lang="C#">
public class MyClass : BaseClass {
    [Export ("initWithFoo:")]
    public MyClass (string foo) : base (NSObjectFlag.Empty)
    {
        ...
    }
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IOBluetoothDevice (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Pointer (handle) to the unmanaged object.</param>
        <summary>A constructor used when creating managed representations of unmanaged objects;  Called by the runtime.</summary>
        <remarks>
          <para>This constructor is invoked by the runtime infrastructure (<see cref="M:MonoMac.ObjCRuntime.GetNSObject (System.IntPtr)" />) to create a new managed representation for a pointer to an unmanaged Objective-C object. You should not invoke this method directly, instead you should call the GetNSObject method as it will prevent two instances of a managed object to point to the same native object.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Address">
      <MemberSignature Language="C#" Value="public MonoMac.IOBluetooth.BluetoothDeviceAddress Address { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoMac.IOBluetooth.BluetoothDeviceAddress Address" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.BluetoothDeviceAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the Bluetooth device address for the target device.</summary>
        <value>The Bluetooth device address of the target device.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddressString">
      <MemberSignature Language="C#" Value="public virtual string AddressString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AddressString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoMac.Foundation.Export("addressString")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Get a string representation of the Bluetooth device address for the target device. The
              format of the string is the same as returned by <see cref="M:MonoMac.IOBluetooth.IOBluetooth.ToNSString(MonoMac.IOBluetooth.BluetoothDeviceAddress)" />.</summary>
        <value>String containing the Bluetooth device address of the target device.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddToFavorites">
      <MemberSignature Language="C#" Value="public void AddToFavorites ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddToFavorites() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.ObjCRuntime.Since(2, 4)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Adds the target device to the user's favorite devices list.</summary>
        <remarks>
        </remarks>
        <exception cref="T:MonoMac.IOKit.IOKitException">If the device was not successfully added to the user's
            list of favorite devices.</exception>
      </Docs>
    </Member>
    <Member MemberName="ClassHandle">
      <MemberSignature Language="C#" Value="public override IntPtr ClassHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ClassHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The handle for this class.</summary>
        <value>The pointer to the Objective-C class.</value>
        <remarks>Each MonoMac class mirrors an unmanaged Objective-C class. This value contains the pointer to the Objective-C class, it is similar to calling objc_getClass with the object name.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClassOfDevice">
      <MemberSignature Language="C#" Value="public virtual MonoMac.IOBluetooth.BluetoothClassOfDevice ClassOfDevice { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoMac.IOBluetooth.BluetoothClassOfDevice ClassOfDevice" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoMac.Foundation.Export("classOfDevice")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.BluetoothClassOfDevice</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the full class of device value for the remote device.</summary>
        <value>The class of device for the remote device.</value>
        <remarks>This value is only meaningful if the target device has been seen during an inquiry. This can be
            by checking <see cref="P:MonoMac.IOBluetooth.IOBluetoothDevice.LastInquiryUpdate" />. If <c>null</c> is returned, then the device hasn't been seen.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClockOffset">
      <MemberSignature Language="C#" Value="public virtual ushort ClockOffset { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int16 ClockOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoMac.Foundation.Export("getClockOffset")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the clock offset value of the device.</summary>
        <value>The clock offset value for the device.</value>
        <remarks>This value is only meaningful if the target device has been seen during an inquiry. This can be
            by checking <see cref="P:MonoMac.IOBluetooth.IOBluetoothDevice.LastInquiryUpdate" />. If <c>null</c> is returned, then the device hasn't been seen.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseConnection">
      <MemberSignature Language="C#" Value="public void CloseConnection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CloseConnection() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Close down the baseband connection to the device.</summary>
        <remarks>This method is synchronous and will not return until the connection has been closed (or the
            command failed). In the future this API will be changed to allow asynchronous operation.</remarks>
        <exception cref="T:MonoMac.IOKit.IOKitException">If the connection was not successfully closed.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConnectionHandle">
      <MemberSignature Language="C#" Value="public virtual ushort ConnectionHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int16 ConnectionHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoMac.Foundation.Export("connectionHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the connection handle for the baseband connection.</summary>
        <value>The connection handle for the baseband connection. If no baseband connection is present,
            <see cref="F:MonoMac.IOBluetooth.IOBluetooth.ConnectionHandleNone" /> is returned.</value>
        <remarks>This method only returns a valid result if a baseband connection is present (<see cref="P:MonoMac.IOBluetooth.IOBluetoothDevice.IsConnected" /> returns <c>true</c>).</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeviceClassMajor">
      <MemberSignature Language="C#" Value="public virtual MonoMac.IOBluetooth.BluetoothDeviceClassMajor DeviceClassMajor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoMac.IOBluetooth.BluetoothDeviceClassMajor DeviceClassMajor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoMac.Foundation.Export("deviceClassMajor")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.BluetoothDeviceClassMajor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the major device class of the device.</summary>
        <value>The major device class of the remote device.</value>
        <remarks>This value is only meaningful if the target device has been seen during an inquiry. This can be
            by checking <see cref="P:MonoMac.IOBluetooth.IOBluetoothDevice.LastInquiryUpdate" />. If <c>null</c> is returned, then the device hasn't been seen.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeviceClassMinor">
      <MemberSignature Language="C#" Value="public virtual MonoMac.IOBluetooth.BluetoothDeviceClassMinor DeviceClassMinor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoMac.IOBluetooth.BluetoothDeviceClassMinor DeviceClassMinor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoMac.Foundation.Export("deviceClassMinor")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.BluetoothDeviceClassMinor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the minor device class of the device.</summary>
        <value>The minor device class of the remote device.</value>
        <remarks>This value is only meaningful if the target device has been seen during an inquiry. This can be
              by checking <see cref="P:MonoMac.IOBluetooth.IOBluetoothDevice.LastInquiryUpdate" />. If <c>null</c> is returned, then the device hasn't been seen.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeviceConnected">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;MonoMac.IOBluetooth.DeviceConnectedEventArgs&gt; DeviceConnected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class MonoMac.IOBluetooth.DeviceConnectedEventArgs&gt; DeviceConnected" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;MonoMac.IOBluetooth.DeviceConnectedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Allows a client to register for device connect notifications for any connection.</summary>
        <remarks>This event is derived from the registerForConnectNotifications:selector: function.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <para>If set to <see langword="true" />, the method is invoked directly and will dispose manage and unmanaged resources;   If set to <see langword="false" /> the method is being called by the garbage collector finalizer and should only release unmanaged resources.</para>
        </param>
        <summary>Releases the resources used by the IOBluetoothDevice object.</summary>
        <remarks>
          <para>This Dispose method releases the resources used by the IOBluetoothDevice class.</para>
          <para>This method is called by both the Dispose() method and the object finalizer (Finalize). When invoked by the Dispose method, the parameter disposting <paramref name="disposing" /> is set to <see langword="true" /> and any managed object references that this object holds are also disposed or released;  when invoked by the object finalizer, on the finalizer thread the value is set to <see langword="false" />. </para>
          <para>Calling the Dispose method when you are finished using the IOBluetoothDevice ensures that all external resources used by this managed object are released as soon as possible. Once you have invoked the Dispose method, the object is no longer useful and you should no longer make any calls to it.</para>
          <para>  For more information on how to override this method and on the Dispose/IDisposable pattern, read the ``Implementing a Dispose Method'' document at http://msdn.microsoft.com/en-us/library/fs2xkftw.aspx</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncryptionMode">
      <MemberSignature Language="C#" Value="public virtual MonoMac.IOBluetooth.BluetoothHCIEncryptionMode EncryptionMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoMac.IOBluetooth.BluetoothHCIEncryptionMode EncryptionMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoMac.Foundation.Export("getEncryptionMode")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.BluetoothHCIEncryptionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the encryption mode for the baseband connection.</summary>
        <value>The encryption mode for the baseband connection. If no baseband connection is present,
            <see cref="F:MonoMac.IOBluetooth.BluetoothHCIEncryptionMode.Disabled" /> is returned.</value>
        <remarks>This method only returns a valid result if a baseband connection is present (<see cref="P:MonoMac.IOBluetooth.IOBluetoothDevice.IsConnected" /> returns <c>true</c>).</remarks>
      </Docs>
    </Member>
    <Member MemberName="FavoriteDevices">
      <MemberSignature Language="C#" Value="public static MonoMac.IOBluetooth.IOBluetoothDevice[] FavoriteDevices { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoMac.IOBluetooth.IOBluetoothDevice[] FavoriteDevices" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.ObjCRuntime.Since(2, 4)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoMac.Foundation.Export("favoriteDevices")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.IOBluetoothDevice[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an array of the user's favorite devices.</summary>
        <value>An array of device objects representing the user's favorite devices. If the
            user has no favorites, <c>null</c> is returned.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeviceWithAddress">
      <MemberSignature Language="C#" Value="public static MonoMac.IOBluetooth.IOBluetoothDevice GetDeviceWithAddress (MonoMac.IOBluetooth.BluetoothDeviceAddress address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class MonoMac.IOBluetooth.IOBluetoothDevice GetDeviceWithAddress(valuetype MonoMac.IOBluetooth.BluetoothDeviceAddress address) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.Foundation.Export("deviceWithAddress:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.IOBluetoothDevice</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="MonoMac.IOBluetooth.BluetoothDeviceAddress" />
      </Parameters>
      <Docs>
        <param name="address">The <see cref="T:MonoMac.IOBluetooth.BluetoothDeviceAddress" /> for which an IOBluetoothDevice instance is desired.</param>
        <summary>Gets the IOBluetoothDevice object for the given <see cref="T:MonoMac.IOBluetooth.BluetoothDeviceAddress" />.</summary>
        <returns>Returns the IOBluetoothDevice object for the given <see cref="T:MonoMac.IOBluetooth.BluetoothDeviceAddress" />.</returns>
        <remarks>Within a single application, there will be only one instance of IOBluetoothDevice for a
            given remote device address.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeviceWithAddress">
      <MemberSignature Language="C#" Value="public static MonoMac.IOBluetooth.IOBluetoothDevice GetDeviceWithAddress (string address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class MonoMac.IOBluetooth.IOBluetoothDevice GetDeviceWithAddress(string address) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.Foundation.Export("deviceWithAddressString:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.IOBluetoothDevice</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="address">String containing the BD_ADDR for which an IOBluetoothDevice instance is desired. The string should be of the form 'xx:xx:xx:xx:xx:xx'.</param>
        <summary>Gets the IOBluetoothDevice object for the given address.</summary>
        <returns>The IOBluetoothDevice object for the given address.</returns>
        <remarks>Within a single application, there will be only one instance of IOBluetoothDevice for a
              given remote device address.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRecentDevices">
      <MemberSignature Language="C#" Value="public static MonoMac.IOBluetooth.IOBluetoothDevice[] GetRecentDevices (ulong numDevices);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class MonoMac.IOBluetooth.IOBluetoothDevice[] GetRecentDevices(unsigned int64 numDevices) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.Foundation.Export("recentDevices:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.IOBluetoothDevice[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="numDevices" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="numDevices">The number of devices to return.</param>
        <summary>Gets an array of recently used Bluetooth devices.</summary>
        <returns>An array of device objects recently used by the system. If no devices have been accessed,
            <c>null</c> is returned.</returns>
        <remarks>The resulting array contains IOBluetoothDevice objects sorted in reverse chronological order.
            The most recently accessed devices are first. If the <paramref name="numDevices" /> parameter is 0, all devices
            accessed by the system are returned. If <paramref name="numDevices" /> is non-zero, only the most recent devices
            are returned.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetServiceRecordForUUID">
      <MemberSignature Language="C#" Value="public virtual MonoMac.IOBluetooth.IOBluetoothSDPServiceRecord GetServiceRecordForUUID (MonoMac.IOBluetooth.IOBluetoothSDPUUID sdpUUID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoMac.IOBluetooth.IOBluetoothSDPServiceRecord GetServiceRecordForUUID(class MonoMac.IOBluetooth.IOBluetoothSDPUUID sdpUUID) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.Foundation.Export("getServiceRecordForUUID:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.IOBluetoothSDPServiceRecord</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sdpUUID" Type="MonoMac.IOBluetooth.IOBluetoothSDPUUID" />
      </Parameters>
      <Docs>
        <param name="sdpUUID">UUID value to search for.</param>
        <summary>Search for a service record containing the given UUID.</summary>
        <returns>The first service record that contains the given uuid. If no service record is found,
            <c>null</c> is returned.</returns>
        <remarks>This method searches through the device's services to find a service that contains the given
            UUID. Only the first service record will be returned. This method only operates on services
            that have already been queried. It will not initiate a new query. This method should probably
            be updated to return an array of service records if more than one contains the UUID.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConnected">
      <MemberSignature Language="C#" Value="public virtual bool IsConnected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConnected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoMac.Foundation.Export("isConnected")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indicates whether a baseband connection to the device exists.</summary>
        <value>
          <c>true</c> if a baseband connection to the device exists.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFavorite">
      <MemberSignature Language="C#" Value="public virtual bool IsFavorite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFavorite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.ObjCRuntime.Since(2, 4)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoMac.Foundation.Export("isFavorite")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reports whether the target device is a favorite for the user.</summary>
        <value>
          <c>true</c> if the target device is a favorite for the user, <c>false</c> if not.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIncoming">
      <MemberSignature Language="C#" Value="public virtual bool IsIncoming { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIncoming" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.ObjCRuntime.Since(2, 7)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoMac.Foundation.Export("isIncoming")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns <c>true</c> if the device connection was generated by the remote host.</summary>
        <value>
        </value>
        <remarks>Returns <c>true</c> if the device connection was generated by the remote host. <c>false</c> if the connection was generated by some other device that connected to the local host.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPaired">
      <MemberSignature Language="C#" Value="public virtual bool IsPaired { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPaired" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.ObjCRuntime.Since(2, 5)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoMac.Foundation.Export("isPaired")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets whether the target device is paired.</summary>
        <value>
          <c>true</c> if the target device is paired, otherwise <c>false</c>.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LastInquiryUpdate">
      <MemberSignature Language="C#" Value="public virtual MonoMac.Foundation.NSDate LastInquiryUpdate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoMac.Foundation.NSDate LastInquiryUpdate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoMac.Foundation.Export("getLastInquiryUpdate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.Foundation.NSDate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the date/time of the last time the device was returned during an inquiry.</summary>
        <value>The date/time of the last time the device was seen during an inquiry.
            If the device has never been seen during an inquiry, <c>null</c> is returned.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LastNameUpdate">
      <MemberSignature Language="C#" Value="public virtual MonoMac.Foundation.NSDate LastNameUpdate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoMac.Foundation.NSDate LastNameUpdate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoMac.Foundation.Export("lastNameUpdate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.Foundation.NSDate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the date/time of the last successful remote name request.</summary>
        <value>The date/time of the last successful remote name request. If no remote name request has been
            completed on the target device, <c>null</c> is returned.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LastServicesUpdate">
      <MemberSignature Language="C#" Value="public virtual MonoMac.Foundation.NSDate LastServicesUpdate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoMac.Foundation.NSDate LastServicesUpdate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoMac.Foundation.Export("getLastServicesUpdate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.Foundation.NSDate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the date/time of the last SDP query.</summary>
        <value>Tthe date/time of the last SDP query. If an SDP query has never been performed on the
            device, <c>null</c> is returned.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LinkType">
      <MemberSignature Language="C#" Value="public virtual MonoMac.IOBluetooth.BluetoothLinkType LinkType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoMac.IOBluetooth.BluetoothLinkType LinkType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoMac.Foundation.Export("getLinkType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.BluetoothLinkType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the link type for the baseband connection.</summary>
        <value>The link type for the baseband connection. If no baseband connection is present,
            <see cref="F:MonoMac.IOBluetooth.BluetoothLinkType.None" /> is returned.</value>
        <remarks>This method only returns a valid result if a baseband connection is present (<see cref="P:MonoMac.IOBluetooth.IOBluetoothDevice.IsConnected" /> returns <c>true</c>).</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public virtual string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoMac.Foundation.Export("name")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the human readable name of the remote device.</summary>
        <value>The name of the remote device name. This value is a string generated from the UTF-8
            format of the most recent remote name request.</value>
        <remarks>This only returns a value if a remote name request has been performed on the target device. If a
            successful remote name request has not been completed, <c>null</c> is returned. To perform a remote
            name request, call <see cref="M:MonoMac.IOBluetooth.IOBluetoothDevice.RequestRemoteName" />. If a remote name request has been successfully completed,
            the property <see cref="P:MonoMac.IOBluetooth.IOBluetoothDevice.LastNameUpdate" /> will return the date/time of the last successful request.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NameOrAddress">
      <MemberSignature Language="C#" Value="public virtual string NameOrAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string NameOrAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoMac.Foundation.Export("nameOrAddress")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the human readable name of the remote device. If the name is not present, it will return a string containing the device's address.</summary>
        <value>The device's name or a string containing the device's address.</value>
        <remarks>If a remote name request has been successfully completed, the device name will be returned. If not,
            a string containg the device address in the format of "XX-XX-XX-XX-XX-XX" will be returned.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenConnection">
      <MemberSignature Language="C#" Value="public void OpenConnection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OpenConnection() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Create a baseband connection to the device.</summary>
        <remarks>
          <para>This method is synchronous and will not return until either a connection has been established
            or the create connection has failed (perhaps timed out). This method does the same thing as
            calling <see cref="M:MonoMac.IOBluetooth.IOBluetoothDevice.OpenConnection(MonoMac.Foundation.NSObject)" /> with a <c>null</c> target. This call will proceed without authentication required, and
            using the default page timeout value. If authentication or a non-default page timeout is required the method
            <see cref="M:MonoMac.IOBluetooth.IOBluetoothDevice.OpenConnection(MonoMac.Foundation.NSObject,System.Uint16,System.Boolean)" /> should be used instead.</para>
          <para>As of Mac OS X 10.7, this method will no longer mask out "Connection Exists" 'errors' and an exception will be thrown; your code must account for the cases where the baseband connection is already open.</para>
        </remarks>
        <exception cref="T:MonoMac.IOKit.IOKitException">If the connection was not successfully created.</exception>
        <seealso cref="M:MonoMac.IOBluetooth.IOBluetoothDevice.OpenDeviceAsync" />
      </Docs>
    </Member>
    <Member MemberName="OpenConnection">
      <MemberSignature Language="C#" Value="public void OpenConnection (MonoMac.Foundation.NSObject target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OpenConnection(class MonoMac.Foundation.NSObject target) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="MonoMac.Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="target">The target to message when the create connection call is complete.</param>
        <summary>Create a baseband connection to the device.</summary>
        <remarks>
          <para>If a target is specified, the open connection call is asynchronous and on completion of the
            CREATE_CONNECTION command, the method <see cref="M:MonoMac.IOBluetooth.IOBluetoothDeviceAsyncCallbacks.ConnectionComplete(MonoMac.IOBluetooth.IOBluetoothDevice,MonoMac.IOKit.IOReturn)" /> (-connectionComplete:status:) will be called on the specified target.
            If no target is specified, the call is synchronous and will not return until the connection is open
            or the CREATE_CONNECTION call has failed. This call will proceed without authentication required, and
            using the default page timeout value. If authentication or a non-default page timeout is required the method
            <see cref="M:MonoMac.IOBluetooth.IOBluetoothDevice.OpenConnection(MonoMac.Foundation.NSObject,System.Uint16,System.Boolean)" /> should be used instead.</para>
          <para>As of Mac OS X 10.7, this method will no longer mask out "Connection Exists" 'errors' and an exeption will be thrown;
            your code must account for the cases where the baseband connection is already open.</para>
        </remarks>
        <exception cref="T:MonoMac.IOKit.IOKitException">If the connection was not successfully created (or if asynchronous, if the CREATE_CONNECTION command was not successfully issued).</exception>
        <seealso cref="M:MonoMac.IOBluetooth.IOBluetoothDevice.OpenDeviceAsync" />
      </Docs>
    </Member>
    <Member MemberName="OpenConnection">
      <MemberSignature Language="C#" Value="public void OpenConnection (MonoMac.Foundation.NSObject target, ushort pageTimeoutValue, bool authenticationRequired);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OpenConnection(class MonoMac.Foundation.NSObject target, unsigned int16 pageTimeoutValue, bool authenticationRequired) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.ObjCRuntime.Since(2, 7)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="MonoMac.Foundation.NSObject" />
        <Parameter Name="pageTimeoutValue" Type="System.UInt16" />
        <Parameter Name="authenticationRequired" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="target">The target to message when the create connection call is complete.</param>
        <param name="pageTimeoutValue">The page timeout value to use for this call.</param>
        <param name="authenticationRequired">Indicates whether authentication should be required for the connection.</param>
        <summary>Create a baseband connection to the device.</summary>
        <remarks>
          <para>If a target is specified, the open connection call is asynchronous and on completion of the
            CREATE_CONNECTION command, the method <see cref="M:MonoMac.IOBluetooth.IOBluetoothDeviceAsyncCallbacks.ConnectionComplete(MonoMac.IOBluetooth.IOBluetoothDevice,MonoMac.IOKit.IOReturn)" /> (-connectionComplete:status:) will be called on the specified target.
            If no target is specified, the call is synchronous and will not return until the connection is open
            or the CREATE_CONNECTION call has failed.</para>
          <para>As of Mac OS X 10.7, this method will no longer mask out "Connection Exists" 'errors' and an exeption will be thrown;
            your code must account for the cases where the baseband connection is already open.</para>
        </remarks>
        <exception cref="T:MonoMac.IOKit.IOKitException">If the connection was not successfully created (or if asynchronous, if the CREATE_CONNECTION command was not successfully issued).</exception>
        <seealso cref="M:MonoMac.IOBluetooth.IOBluetoothDevice.OpenDeviceAsync(System.Uint16,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="OpenConnectionAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;MonoMac.IOBluetooth.IOBluetoothDevice&gt; OpenConnectionAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class MonoMac.IOBluetooth.IOBluetoothDevice&gt; OpenConnectionAsync() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;MonoMac.IOBluetooth.IOBluetoothDevice&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Create a baseband connection to the device.</summary>
        <returns>A Task object. Call Task.Result or Task.ContinueWith(...) to check the success of the command.</returns>
        <remarks>
          <para>If no target is specified, the call is synchronous and will not return until the connection is open
            or the CREATE_CONNECTION call has failed. This call will proceed without authentication required, and
            using the default page timeout value. If authentication or a non-default page timeout is required the method
            <see cref="M:MonoMac.IOBluetooth.IOBluetoothDevice.OpenConnectionAsync(System.Uint16,System.Boolean)" /> should be used instead.</para>
          <para>As of Mac OS X 10.7, this method will no longer mask out "Connection Exists" 'errors' and an exeption will be thrown;
            your code must account for the cases where the baseband connection is already open.</para>
        </remarks>
        <exception cref="T:MonoMac.IOKit.IOKitException">If the CREATE_CONNECTION command was not successfully issued.</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenConnectionAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;MonoMac.IOBluetooth.IOBluetoothDevice&gt; OpenConnectionAsync (ushort pageTimeoutValue, bool authenticationRequired);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class MonoMac.IOBluetooth.IOBluetoothDevice&gt; OpenConnectionAsync(unsigned int16 pageTimeoutValue, bool authenticationRequired) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;MonoMac.IOBluetooth.IOBluetoothDevice&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pageTimeoutValue" Type="System.UInt16" />
        <Parameter Name="authenticationRequired" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="pageTimeoutValue">The page timeout value to use for this call.</param>
        <param name="authenticationRequired">Indicates whether authentication should be required for the connection.</param>
        <summary>Create a baseband connection to the device.</summary>
        <returns>A Task object. Call Task.Result or Task.ContinueWith(...) to check the success of the command.</returns>
        <remarks>As of Mac OS X 10.7, this method will no longer mask out "Connection Exists" 'errors' and an exeption will be thrown;
            your code must account for the cases where the baseband connection is already open.</remarks>
        <exception cref="T:MonoMac.IOKit.IOKitException">If the CREATE_CONNECTION command was not successfully issued.</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenL2CAPChannel">
      <MemberSignature Language="C#" Value="public MonoMac.IOBluetooth.IOBluetoothL2CAPChannel OpenL2CAPChannel (MonoMac.IOBluetooth.BluetoothL2CAPPSM psm = MonoMac.IOBluetooth.BluetoothL2CAPPSM.None, MonoMac.Foundation.NSObject channelDelegate = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class MonoMac.IOBluetooth.IOBluetoothL2CAPChannel OpenL2CAPChannel(valuetype MonoMac.IOBluetooth.BluetoothL2CAPPSM psm, class MonoMac.Foundation.NSObject channelDelegate) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.ObjCRuntime.Since(2, 5)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.IOBluetoothL2CAPChannel</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="psm" Type="MonoMac.IOBluetooth.BluetoothL2CAPPSM" />
        <Parameter Name="channelDelegate" Type="MonoMac.Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="psm">The L2CAP PSM value for the new channel.</param>
        <param name="channelDelegate">The object that will play the role of delegate for the channel.
          A channel delegate is the object the L2CAP uses as target for data and events. The
          developer will implement only the the methods he/she is interested in. A list of the
          possible methods can be found in <see cref="T:MonoMac.IOBluetooth.IOBluetoothL2CAPChannelDelegate" />.</param>
        <summary>Opens a new L2CAP channel to the target device. Returns only after the channel is opened.</summary>
        <returns>The L2CAP channel requested to be opened.</returns>
        <remarks>
          <para>This method will begin the process of opening a new L2CAP channel to the target device.
          The baseband connection to the device will be opened if it is not open already.</para>
        </remarks>
        <exception cref="T:MonoMac.IOKit.IOKitException">If an existing L2CAP channel was not found and the open process was not successfully started.</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenL2CAPChannel">
      <MemberSignature Language="C#" Value="public MonoMac.IOBluetooth.IOBluetoothL2CAPChannel OpenL2CAPChannel (MonoMac.IOBluetooth.BluetoothL2CAPPSM psm, MonoMac.IOBluetooth.IOBluetoothL2CAPChannelDelegate channelDelegate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class MonoMac.IOBluetooth.IOBluetoothL2CAPChannel OpenL2CAPChannel(valuetype MonoMac.IOBluetooth.BluetoothL2CAPPSM psm, class MonoMac.IOBluetooth.IOBluetoothL2CAPChannelDelegate channelDelegate) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.ObjCRuntime.Since(2, 5)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.IOBluetoothL2CAPChannel</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="psm" Type="MonoMac.IOBluetooth.BluetoothL2CAPPSM" />
        <Parameter Name="channelDelegate" Type="MonoMac.IOBluetooth.IOBluetoothL2CAPChannelDelegate" />
      </Parameters>
      <Docs>
        <param name="psm">The L2CAP PSM value for the new channel.</param>
        <param name="channelDelegate">The object that will play the role of delegate for the channel.
              A channel delegate is the object the L2CAP uses as target for data and events.</param>
        <summary>Opens a new L2CAP channel to the target device. Returns only after the channel is opened.</summary>
        <returns>The L2CAP channel requested to be opened.</returns>
        <remarks>
          <para>This method will begin the process of opening a new L2CAP channel to the target device.
              The baseband connection to the device will be opened if it is not open already.</para>
        </remarks>
        <exception cref="T:MonoMac.IOKit.IOKitException">If an existing L2CAP channel was not found and the open process was not successfully started.</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenL2CAPChannel">
      <MemberSignature Language="C#" Value="public MonoMac.IOBluetooth.IOBluetoothL2CAPChannel OpenL2CAPChannel (MonoMac.IOBluetooth.BluetoothL2CAPPSM psm, MonoMac.Foundation.NSDictionary channelConfiguration, MonoMac.Foundation.NSObject channelDelegate = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class MonoMac.IOBluetooth.IOBluetoothL2CAPChannel OpenL2CAPChannel(valuetype MonoMac.IOBluetooth.BluetoothL2CAPPSM psm, class MonoMac.Foundation.NSDictionary channelConfiguration, class MonoMac.Foundation.NSObject channelDelegate) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.IOBluetoothL2CAPChannel</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="psm" Type="MonoMac.IOBluetooth.BluetoothL2CAPPSM" />
        <Parameter Name="channelConfiguration" Type="MonoMac.Foundation.NSDictionary" />
        <Parameter Name="channelDelegate" Type="MonoMac.Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="psm">The L2CAP PSM value for the new channel.</param>
        <param name="channelConfiguration">The dictionary that describes the initial configuration for the channel.</param>
        <param name="channelDelegate">The delegate the object that will play the role of delegate for the channel.
            A channel delegate is the object the l2cap uses as target for  data and events. The
            developer will implement only the the methods he/she is interested in. A list of the
            possible methods can be found in <see cref="T:MonoMac.IOBluetooth.IOBluetoothL2CAPChannelDelegate" />.</param>
        <summary>Opens a new L2CAP channel to the target device. Returns only after the channel is opened.</summary>
        <returns>The L2CAP channel requested to be opened.</returns>
        <remarks>This method will begin the process of opening a new L2CAP channel to the target device.
            The baseband connection to the device will be opened if it is not open already.</remarks>
        <exception cref="T:MonoMac.IOKit.IOKitException">If an existing L2CAP channel was not found and the open process was not successfully started.</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenL2CAPChannel">
      <MemberSignature Language="C#" Value="public MonoMac.IOBluetooth.IOBluetoothL2CAPChannel OpenL2CAPChannel (MonoMac.IOBluetooth.BluetoothL2CAPPSM psm, MonoMac.Foundation.NSDictionary channelConfiguration, MonoMac.IOBluetooth.IOBluetoothL2CAPChannelDelegate channelDelegate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class MonoMac.IOBluetooth.IOBluetoothL2CAPChannel OpenL2CAPChannel(valuetype MonoMac.IOBluetooth.BluetoothL2CAPPSM psm, class MonoMac.Foundation.NSDictionary channelConfiguration, class MonoMac.IOBluetooth.IOBluetoothL2CAPChannelDelegate channelDelegate) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.IOBluetoothL2CAPChannel</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="psm" Type="MonoMac.IOBluetooth.BluetoothL2CAPPSM" />
        <Parameter Name="channelConfiguration" Type="MonoMac.Foundation.NSDictionary" />
        <Parameter Name="channelDelegate" Type="MonoMac.IOBluetooth.IOBluetoothL2CAPChannelDelegate" />
      </Parameters>
      <Docs>
        <param name="psm">The L2CAP PSM value for the new channel.</param>
        <param name="channelConfiguration">The dictionary that describes the initial configuration for the channel.</param>
        <param name="channelDelegate">The delegate the object that will play the role of delegate for the channel.
            A channel delegate is the object the l2cap uses as target for  data and events.</param>
        <summary>Opens a new L2CAP channel to the target device. Returns only after the channel is opened.</summary>
        <returns>The L2CAP channel requested to be opened.</returns>
        <remarks>This method will begin the process of opening a new L2CAP channel to the target device.
            The baseband connection to the device will be opened if it is not open already.</remarks>
        <exception cref="T:MonoMac.IOKit.IOKitException">If an existing L2CAP channel was not found and the open process was not successfully started.</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenL2CAPChannelAsync">
      <MemberSignature Language="C#" Value="public MonoMac.IOBluetooth.IOBluetoothL2CAPChannel OpenL2CAPChannelAsync (MonoMac.IOBluetooth.BluetoothL2CAPPSM psm = MonoMac.IOBluetooth.BluetoothL2CAPPSM.None, MonoMac.Foundation.NSObject channelDelegate = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class MonoMac.IOBluetooth.IOBluetoothL2CAPChannel OpenL2CAPChannelAsync(valuetype MonoMac.IOBluetooth.BluetoothL2CAPPSM psm, class MonoMac.Foundation.NSObject channelDelegate) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.ObjCRuntime.Since(2, 5)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.IOBluetoothL2CAPChannel</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="psm" Type="MonoMac.IOBluetooth.BluetoothL2CAPPSM" />
        <Parameter Name="channelDelegate" Type="MonoMac.Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="psm">The L2CAP PSM value for the new channel.</param>
        <param name="channelDelegate">The object that will play the role of delegate for the channel.
            A channel delegate is the object the L2CAP uses as target for data and events. The
            developer will implement only the the methods he/she is interested in. A list of the
            possible methods can be found in <see cref="T:MonoMac.IOBluetooth.IOBluetoothL2CAPChannelDelegate" />.</param>
        <summary>Opens a new L2CAP channel to the target device. Returns immediately after starting the opening process.</summary>
        <returns>The L2CAP channel requested to be opened.</returns>
        <remarks>
          <para>This method will begin the process of opening a new L2CAP channel to the target device.
            The baseband connection to the device will be opened if it is not open already.</para>
          <para>Use the <see cref="E:MonoMac.IOBluetooth.IOBluetoothL2CAPChannel.Opened" /> event to handle the channel when it is opened.</para>
        </remarks>
        <exception cref="T:MonoMac.IOKit.IOKitException">If an existing L2CAP channel was not found and the open process was not successfully started.</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenL2CAPChannelAsync">
      <MemberSignature Language="C#" Value="public MonoMac.IOBluetooth.IOBluetoothL2CAPChannel OpenL2CAPChannelAsync (MonoMac.IOBluetooth.BluetoothL2CAPPSM psm, MonoMac.IOBluetooth.IOBluetoothL2CAPChannelDelegate channelDelegate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class MonoMac.IOBluetooth.IOBluetoothL2CAPChannel OpenL2CAPChannelAsync(valuetype MonoMac.IOBluetooth.BluetoothL2CAPPSM psm, class MonoMac.IOBluetooth.IOBluetoothL2CAPChannelDelegate channelDelegate) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.ObjCRuntime.Since(2, 5)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.IOBluetoothL2CAPChannel</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="psm" Type="MonoMac.IOBluetooth.BluetoothL2CAPPSM" />
        <Parameter Name="channelDelegate" Type="MonoMac.IOBluetooth.IOBluetoothL2CAPChannelDelegate" />
      </Parameters>
      <Docs>
        <param name="psm">The L2CAP PSM value for the new channel.</param>
        <param name="channelDelegate">The object that will play the role of delegate for the channel.
            A channel delegate is the object the L2CAP uses as target for data and events.</param>
        <summary>Opens a new L2CAP channel to the target device. Returns immediately after starting the opening process.</summary>
        <returns>The L2CAP channel requested to be opened.</returns>
        <remarks>
          <para>This method will begin the process of opening a new L2CAP channel to the target device.
            The baseband connection to the device will be opened if it is not open already.</para>
          <para>Use the <see cref="E:MonoMac.IOBluetooth.IOBluetoothL2CAPChannel.Opened" /> event to handle the channel when it is opened.</para>
        </remarks>
        <exception cref="T:MonoMac.IOKit.IOKitException">If an existing L2CAP channel was not found and the open process was not successfully started.</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenL2CAPChannelAsync">
      <MemberSignature Language="C#" Value="public MonoMac.IOBluetooth.IOBluetoothL2CAPChannel OpenL2CAPChannelAsync (MonoMac.IOBluetooth.BluetoothL2CAPPSM psm, MonoMac.Foundation.NSDictionary channelConfiguration, MonoMac.Foundation.NSObject channelDelegate = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class MonoMac.IOBluetooth.IOBluetoothL2CAPChannel OpenL2CAPChannelAsync(valuetype MonoMac.IOBluetooth.BluetoothL2CAPPSM psm, class MonoMac.Foundation.NSDictionary channelConfiguration, class MonoMac.Foundation.NSObject channelDelegate) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.IOBluetoothL2CAPChannel</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="psm" Type="MonoMac.IOBluetooth.BluetoothL2CAPPSM" />
        <Parameter Name="channelConfiguration" Type="MonoMac.Foundation.NSDictionary" />
        <Parameter Name="channelDelegate" Type="MonoMac.Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="psm">The L2CAP PSM value for the new channel.</param>
        <param name="channelConfiguration">The dictionary that describes the initial configuration for the channel.</param>
        <param name="channelDelegate">The delegate the object that will play the role of delegate for the channel.
              A channel delegate is the object the l2cap uses as target for  data and events. The
              developer will implement only the the methods he/she is interested in. A list of the
              possible methods can be found in <see cref="T:MonoMac.IOBluetooth.IOBluetoothL2CAPChannelDelegate" />.</param>
        <summary>Opens a new L2CAP channel to the target device. Returns immediately after starting the opening process.</summary>
        <returns>The L2CAP channel requested to be opened.</returns>
        <remarks>This method will begin the process of opening a new L2CAP channel to the target device.
              The baseband connection to the device will be opened if it is not open already.</remarks>
        <exception cref="T:MonoMac.IOKit.IOKitException">If an existing L2CAP channel was not found and the open process was not successfully started.</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenL2CAPChannelAsync">
      <MemberSignature Language="C#" Value="public MonoMac.IOBluetooth.IOBluetoothL2CAPChannel OpenL2CAPChannelAsync (MonoMac.IOBluetooth.BluetoothL2CAPPSM psm, MonoMac.Foundation.NSDictionary channelConfiguration, MonoMac.IOBluetooth.IOBluetoothL2CAPChannelDelegate channelDelegate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class MonoMac.IOBluetooth.IOBluetoothL2CAPChannel OpenL2CAPChannelAsync(valuetype MonoMac.IOBluetooth.BluetoothL2CAPPSM psm, class MonoMac.Foundation.NSDictionary channelConfiguration, class MonoMac.IOBluetooth.IOBluetoothL2CAPChannelDelegate channelDelegate) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.IOBluetoothL2CAPChannel</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="psm" Type="MonoMac.IOBluetooth.BluetoothL2CAPPSM" />
        <Parameter Name="channelConfiguration" Type="MonoMac.Foundation.NSDictionary" />
        <Parameter Name="channelDelegate" Type="MonoMac.IOBluetooth.IOBluetoothL2CAPChannelDelegate" />
      </Parameters>
      <Docs>
        <param name="psm">The L2CAP PSM value for the new channel.</param>
        <param name="channelConfiguration">The dictionary that describes the initial configuration for the channel.</param>
        <param name="channelDelegate">The delegate the object that will play the role of delegate for the channel.
              A channel delegate is the object the l2cap uses as target for  data and events.</param>
        <summary>Opens a new L2CAP channel to the target device. Returns immediately after starting the opening process.</summary>
        <returns>The L2CAP channel requested to be opened.</returns>
        <remarks>This method will begin the process of opening a new L2CAP channel to the target device.
              The baseband connection to the device will be opened if it is not open already.</remarks>
        <exception cref="T:MonoMac.IOKit.IOKitException">If an existing L2CAP channel was not found and the open process was not successfully started.</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenRFCOMMChannel">
      <MemberSignature Language="C#" Value="public MonoMac.IOBluetooth.IOBluetoothRFCOMMChannel OpenRFCOMMChannel (byte channelID, MonoMac.Foundation.NSObject channelDelegate = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class MonoMac.IOBluetooth.IOBluetoothRFCOMMChannel OpenRFCOMMChannel(unsigned int8 channelID, class MonoMac.Foundation.NSObject channelDelegate) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.ObjCRuntime.Since(2, 5)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.IOBluetoothRFCOMMChannel</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="channelID" Type="System.Byte" />
        <Parameter Name="channelDelegate" Type="MonoMac.Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="channelID">The RFCOMM channel ID for the new channel.</param>
        <param name="channelDelegate">The object that will play the role of delegate for the channel.
            A channel delegate is the object the rfcomm uses as target for data and events. The
            developer will implement only the the methods he/she is interested in. A list of the
            possible methods can be found int <see cref="T:MonoMac.IOBluetooth.IOBluetoothRFCOMMChannelDelegate" />.</param>
        <summary>Opens a new RFCOMM channel to the target device. Returns only once the channel is open or failed to open.</summary>
        <returns>The RFCOMM channel requested to be opened.</returns>
        <remarks>
          <para>This method will begin the process of opening a new RFCOMM channel to the target device.
            The baseband connection to the device will be opened if it is not open already.</para>
          <para>You should verify that the channel you wish to open exists on the remote device before attempting to open it,
            by performing an SDP query. This is recommended because the service might have been removed from the,
            remote device or the channel assignments for the service could have changed (this is rare, but it does happen
            frequently on some devices). This also works around a bug that existed in early Leopard versions in certain
            situations where the method would return an error; in these instances, the desired RFCOMM channel could not
            be opened again until the calling app was restarted.</para>
        </remarks>
        <exception cref="T:MonoMac.IOKit.IOKitException">If an existing RFCOMM channel was not found and the open process was not successfully started.</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenRFCOMMChannel">
      <MemberSignature Language="C#" Value="public MonoMac.IOBluetooth.IOBluetoothRFCOMMChannel OpenRFCOMMChannel (byte channelID, MonoMac.IOBluetooth.IOBluetoothRFCOMMChannelDelegate channelDelegate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class MonoMac.IOBluetooth.IOBluetoothRFCOMMChannel OpenRFCOMMChannel(unsigned int8 channelID, class MonoMac.IOBluetooth.IOBluetoothRFCOMMChannelDelegate channelDelegate) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.ObjCRuntime.Since(2, 5)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.IOBluetoothRFCOMMChannel</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="channelID" Type="System.Byte" />
        <Parameter Name="channelDelegate" Type="MonoMac.IOBluetooth.IOBluetoothRFCOMMChannelDelegate" />
      </Parameters>
      <Docs>
        <param name="channelID">The RFCOMM channel ID for the new channel.</param>
        <param name="channelDelegate">The object that will play the role of delegate for the channel.
            A channel delegate is the object the rfcomm uses as target for data and events.</param>
        <summary>Opens a new RFCOMM channel to the target device. Returns only once the channel is open or failed to open.</summary>
        <returns>The RFCOMM channel requested to be opened.</returns>
        <remarks>
          <para>This method will begin the process of opening a new RFCOMM channel to the target device.
            The baseband connection to the device will be opened if it is not open already.</para>
          <para>You should verify that the channel you wish to open exists on the remote device before attempting to open it,
            by performing an SDP query. This is recommended because the service might have been removed from the,
            remote device or the channel assignments for the service could have changed (this is rare, but it does happen
            frequently on some devices). This also works around a bug that existed in early Leopard versions in certain
            situations where the method would return an error; in these instances, the desired RFCOMM channel could not
            be opened again until the calling app was restarted.</para>
        </remarks>
        <exception cref="T:MonoMac.IOKit.IOKitException">If an existing RFCOMM channel was not found and the open process was not successfully started.</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenRFCOMMChannelAsync">
      <MemberSignature Language="C#" Value="public MonoMac.IOBluetooth.IOBluetoothRFCOMMChannel OpenRFCOMMChannelAsync (byte channelID, MonoMac.Foundation.NSObject channelDelegate = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class MonoMac.IOBluetooth.IOBluetoothRFCOMMChannel OpenRFCOMMChannelAsync(unsigned int8 channelID, class MonoMac.Foundation.NSObject channelDelegate) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.ObjCRuntime.Since(2, 5)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.IOBluetoothRFCOMMChannel</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="channelID" Type="System.Byte" />
        <Parameter Name="channelDelegate" Type="MonoMac.Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="channelID">The RFCOMM channel ID for the new channel.</param>
        <param name="channelDelegate">The object that will play the role of delegate for the channel.
            A channel delegate is the object the rfcomm uses as target for data and events. The
            developer will implement only the the methods he/she is interested in. A list of the
            possible methods can be found int <see cref="T:MonoMac.IOBluetooth.IOBluetoothRFCOMMChannelDelegate" />.</param>
        <summary>Opens a new RFCOMM channel to the target device. Returns immediately.</summary>
        <returns>The RFCOMM channel requested to be opened.</returns>
        <remarks>
          <para>This method will begin the process of opening a new RFCOMM channel to the target device.
            The baseband connection to the device will be opened if it is not open already.</para>
          <para>You should verify that the channel you wish to open exists on the remote device before attempting to open it,
            by performing an SDP query. This is recommended because the service might have been removed from the,
            remote device or the channel assignments for the service could have changed (this is rare, but it does happen
            frequently on some devices). This also works around a bug that existed in early Leopard versions in certain
            situations where the method would return an error; in these instances, the desired RFCOMM channel could not
            be opened again until the calling app was restarted.</para>
        </remarks>
        <exception cref="T:MonoMac.IOKit.IOKitException">If an existing RFCOMM channel was not found and the open process was not successfully started.</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenRFCOMMChannelAsync">
      <MemberSignature Language="C#" Value="public MonoMac.IOBluetooth.IOBluetoothRFCOMMChannel OpenRFCOMMChannelAsync (byte channelID, MonoMac.IOBluetooth.IOBluetoothRFCOMMChannelDelegate channelDelegate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class MonoMac.IOBluetooth.IOBluetoothRFCOMMChannel OpenRFCOMMChannelAsync(unsigned int8 channelID, class MonoMac.IOBluetooth.IOBluetoothRFCOMMChannelDelegate channelDelegate) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.ObjCRuntime.Since(2, 5)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.IOBluetoothRFCOMMChannel</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="channelID" Type="System.Byte" />
        <Parameter Name="channelDelegate" Type="MonoMac.IOBluetooth.IOBluetoothRFCOMMChannelDelegate" />
      </Parameters>
      <Docs>
        <param name="channelID">The RFCOMM channel ID for the new channel.</param>
        <param name="channelDelegate">The object that will play the role of delegate for the channel.
            A channel delegate is the object the rfcomm uses as target for data and events.</param>
        <summary>Opens a new RFCOMM channel to the target device. Returns immediately.</summary>
        <returns>The RFCOMM channel requested to be opened.</returns>
        <remarks>
          <para>This method will begin the process of opening a new RFCOMM channel to the target device.
            The baseband connection to the device will be opened if it is not open already.</para>
          <para>You should verify that the channel you wish to open exists on the remote device before attempting to open it,
            by performing an SDP query. This is recommended because the service might have been removed from the,
            remote device or the channel assignments for the service could have changed (this is rare, but it does happen
            frequently on some devices). This also works around a bug that existed in early Leopard versions in certain
            situations where the method would return an error; in these instances, the desired RFCOMM channel could not
            be opened again until the calling app was restarted.</para>
        </remarks>
        <exception cref="T:MonoMac.IOKit.IOKitException">If an existing RFCOMM channel was not found and the open process was not successfully started.</exception>
      </Docs>
    </Member>
    <Member MemberName="PageScanMode">
      <MemberSignature Language="C#" Value="public virtual MonoMac.IOBluetooth.BluetoothPageScanMode PageScanMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoMac.IOBluetooth.BluetoothPageScanMode PageScanMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoMac.Foundation.Export("getPageScanMode")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.BluetoothPageScanMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the page scan mode for the device.</summary>
        <value>The value for the page scan mode for the device.</value>
        <remarks>This value is only meaningful if the target device has been seen during an inquiry. This can be
            by checking the result of <see cref="P:MonoMac.IOBluetooth.IOBluetoothDevice.LastInquirryUpdate" />. If <c>null</c> is returned, then the device hasn't been seen.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PageScanPeriodMode">
      <MemberSignature Language="C#" Value="public virtual MonoMac.IOBluetooth.BluetoothPageScanPeriodMode PageScanPeriodMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoMac.IOBluetooth.BluetoothPageScanPeriodMode PageScanPeriodMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoMac.Foundation.Export("getPageScanPeriodMode")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.BluetoothPageScanPeriodMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the value of the page scan period mode for the device.</summary>
        <value>The page scan period mode value for the devicee.</value>
        <remarks>This value is only meaningful if the target device has been seen during an inquiry. This can be
            by checking the result of <see cref="P:MonoMac.IOBluetooth.IOBluetoothDevice.LastInquirryUpdate" />. If <c>null</c> is returned, then the device hasn't been seen.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PageScanRepetitionMode">
      <MemberSignature Language="C#" Value="public virtual MonoMac.IOBluetooth.BluetoothPageScanRepetitionMode PageScanRepetitionMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoMac.IOBluetooth.BluetoothPageScanRepetitionMode PageScanRepetitionMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoMac.Foundation.Export("getPageScanRepetitionMode")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.BluetoothPageScanRepetitionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the value of the page scan repetition mode for the device.</summary>
        <value>The page scan repetition mode value for this device.</value>
        <remarks>This value is only meaningful if the target device has been seen during an inquiry. This can be
            by checking the result of <see cref="P:MonoMac.IOBluetooth.IOBluetoothDevice.LastInquirryUpdate" />. If <c>null</c> is returned, then the device hasn't been seen.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PairedDevices">
      <MemberSignature Language="C#" Value="public static MonoMac.IOBluetooth.IOBluetoothDevice[] PairedDevices { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoMac.IOBluetooth.IOBluetoothDevice[] PairedDevices" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.ObjCRuntime.Since(2, 5)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoMac.Foundation.Export("pairedDevices")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.IOBluetoothDevice[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an array of all of the paired devices on the system.</summary>
        <value>An array of device objects for all of the paired devices on the system. If there are
            no paired devices, <c>null</c> is returned.</value>
        <remarks>The paired devices are currently NOT stored per user, so this is all devices paired by any user.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformSDPQuery">
      <MemberSignature Language="C#" Value="public void PerformSDPQuery (MonoMac.Foundation.NSObject target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PerformSDPQuery(class MonoMac.Foundation.NSObject target) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="MonoMac.Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="target">The target to message when the SDP query is complete.</param>
        <summary>Performs an SDP query on the target device.</summary>
        <remarks>As a result of this call, a baseband connection will be built to the device (if not already connected).
            Then, an L2CAP channel will be opened to the SDP server on the device. At that point, a Service
            Search Attribute request will be issued with a UUID of 0x0100 (L2CAP) and an attribute range of
            0x0000 - 0xffff specified. This will cause the SDP server to return all attributes of all L2CAP-derived
            services on the device. The results essentially encompass all services on the device.
            This function is always asynchronous. If a target is specified, when the SDP query is complete (or
            an error is encountered), the method <see cref="M:MonoMac.IOBluetooth.IOBluetoothDeviceAsyncCallbacks.SdpQueryComplete(MonoMac.IOBluetooth.IOBluetoothDevice,MonoMac.IOKit.IOResult)" /> (-sdpQueryComplete:status:) will be called on the given target. If no target
            is specified, the request is still asynchronous, but no callback will be made. That can be useful if the client
            has	registered for SDP service changed notifications.</remarks>
        <exception cref="T:MonoMac.IOKit.IOKitException">If the SDP query was not successfully started.</exception>
      </Docs>
    </Member>
    <Member MemberName="PerformSDPQuery">
      <MemberSignature Language="C#" Value="public void PerformSDPQuery (MonoMac.Foundation.NSObject target, MonoMac.IOBluetooth.IOBluetoothSDPUUID[] uuids);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PerformSDPQuery(class MonoMac.Foundation.NSObject target, class MonoMac.IOBluetooth.IOBluetoothSDPUUID[] uuids) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="MonoMac.Foundation.NSObject" />
        <Parameter Name="uuids" Type="MonoMac.IOBluetooth.IOBluetoothSDPUUID[]" />
      </Parameters>
      <Docs>
        <param name="target">The target to message when the SDP query is complete.</param>
        <param name="uuids">An array of IOBluetoothSDPUUID objects for each service the caller is interested in.</param>
        <summary>Performs an SDP query on the target device with the specified service UUIDs.</summary>
        <remarks>
          <para>As a result of this call, a baseband connection will be built to the device (if not already connected).
            Then, an L2CAP channel will be opened to the SDP server on the device. At that point, a Service
            Search Attribute request will be issued for each service UUID specified in the UUID array.</para>
          <para>This function is always asynchronous. If a target is specified, when the SDP query is complete (or
            an error is encountered), the method <see cref="M:MonoMac.IOBluetooth.IOBluetoothDeviceAsyncCallbacks.SdpQueryComplete(MonoMac.IOBluetooth.IOBluetoothDevice,MonoMac.IOKit.IOResult)" /> (-sdpQueryComplete:status:) will be called on the given target. If no target
            is specified, the request is still asynchronous, but no callback will be made. That can be useful if the client
            has	registered for SDP service changed notifications.</para>
        </remarks>
        <exception cref="T:MonoMac.IOKit.IOKitException">If the SDP query was not successfully started.</exception>
      </Docs>
    </Member>
    <Member MemberName="RawRSSI">
      <MemberSignature Language="C#" Value="public virtual sbyte RawRSSI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int8 RawRSSI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoMac.Foundation.Export("rawRSSI")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the raw RSSI device (if connected).</summary>
        <value>The raw RSSI of the device.</value>
        <remarks>This value is the perceived RSSI value, not relative the the golden range (see <see cref="P:MonoMac.IOBluetooth.IOBluetoothDevice.RSSI" /> for that value).
            This value will not available on all Bluetooth modules. If the value cannot be read (e.g. the device
            is disconnected) or is not available on a module, a value of +127 will be returned.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RecentAccessDate">
      <MemberSignature Language="C#" Value="public virtual MonoMac.Foundation.NSDate RecentAccessDate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoMac.Foundation.NSDate RecentAccessDate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.ObjCRuntime.Since(2, 4)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoMac.Foundation.Export("recentAccessDate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.Foundation.NSDate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the date/time of the most recent access of the target device.</summary>
        <value>The date/time of the most recent access of the target device. If the device
            has not been accessed, <c>null</c> is returned.</value>
        <remarks>This is the date that <see cref="M:MonoMac.IOBluetooth.IOBluetoothDevice.GetRecentDevices(System.Uint16)" /> uses to sort its list of the most recently accessed devices.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveFromFavorites">
      <MemberSignature Language="C#" Value="public void RemoveFromFavorites ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveFromFavorites() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.ObjCRuntime.Since(2, 4)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Removes the target device from the user's favorite devices list.</summary>
        <remarks>
        </remarks>
        <exception cref="T:MonoMac.IOKit.IOKitException">If the device was not successfully removed from the user's
            list of favorite devices.</exception>
      </Docs>
    </Member>
    <Member MemberName="RequestAuthentication">
      <MemberSignature Language="C#" Value="public void RequestAuthentication ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RequestAuthentication() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Requests that the existing baseband connection be authenticated.</summary>
        <remarks>In order to authenticate a baseband connection, a link key needs to be generated as a result of
              the pairing process. This call will synchronously initiate the pairing process with the target device
              and not return until the authentication process is complete. This API will be updated to allow
              for asynchronous operation.</remarks>
        <exception cref="T:MonoMac.IOKit.IOKitException">If authentication fails or no baseband connection exists.</exception>
      </Docs>
    </Member>
    <Member MemberName="RequestRemoteName">
      <MemberSignature Language="C#" Value="public void RequestRemoteName (MonoMac.Foundation.NSObject target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RequestRemoteName(class MonoMac.Foundation.NSObject target) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="MonoMac.Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="target">The target to message when the remote name request is complete.</param>
        <summary>Issues a remote name request to the target device.</summary>
        <remarks>If a target is specified, the request is asynchronous and on completion of the REMOTE_NAME_REQUEST
            command, the method <see cref="M:MonoMac.IOBluetooth.IOBluetoothDeviceAsyncCallbacks.RequestRemoteNameComplete(MonoMac.IOBluetooth.IOBluetoothDevice,MonoMac.IOKit.IOReturn)" /> (-remoteNameRequestComplete:status:) will be called on the specified target.
            If no target is specified, the request is made synchronously and won't return until the request is
            complete. This call with operate with the default page timeout value. If a different page timeout
            value is desired, the method <see cref="M:MonoMac.IOBluetooth.RequestRemoteName(MonoMac.Foundation.NSObject, System.UInt16,System.Boolean)" /> should be used instead.</remarks>
        <exception cref="T:MonoMac.IOKit.IOKitException">If the remote name request was not successfully issued (or if synchronous, if
            the request did not complete successfully).</exception>
      </Docs>
    </Member>
    <Member MemberName="RequestRemoteName">
      <MemberSignature Language="C#" Value="public void RequestRemoteName (MonoMac.Foundation.NSObject target, ushort pageTimeoutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RequestRemoteName(class MonoMac.Foundation.NSObject target, unsigned int16 pageTimeoutValue) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.ObjCRuntime.Since(2, 7)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="MonoMac.Foundation.NSObject" />
        <Parameter Name="pageTimeoutValue" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="target">The page timeout value to use for this call.</param>
        <param name="pageTimeoutValue">The page timeout value to use for this call.</param>
        <summary>Issues a remote name request to the target device.</summary>
        <remarks>If a target is specified, the request is asynchronous and on completion of the REMOTE_NAME_REQUEST
            command, the method <see cref="M:MonoMac.IOBluetooth.IOBluetoothDeviceAsyncCallbacks.RequestRemoteNameComplete(MonoMac.IOBluetooth.IOBluetoothDevice,MonoMac.IOKit.IOReturn)" /> (-remoteNameRequestComplete:status:) will be called on the specified target.
            If no target is specified, the request is made synchronously and won't return until the request is
            complete.</remarks>
        <exception cref="T:MonoMac.IOKit.IOKitException">If the remote name request was not successfully issued (or if synchronous, if
            the request did not complete successfully).</exception>
      </Docs>
    </Member>
    <Member MemberName="RSSI">
      <MemberSignature Language="C#" Value="public virtual sbyte RSSI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int8 RSSI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoMac.Foundation.Export("RSSI")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the RSSI device (if connected), above or below the golden range. If the RSSI is within the golden
              range, a value of 0 is returned. For the actual RSSI value, use <see cref="P:MonoMac.IOBluetooth.IOBluetoothDevice.RawRSSI" />. For more information, see
              the Bluetooth 4.0 Core Specification.</summary>
        <value>Tthe RSSI of the device. If the value cannot be read (e.g. the device is disconnected), a value
              of +127 will be returned.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SendL2CAPEchoRequest">
      <MemberSignature Language="C#" Value="public void SendL2CAPEchoRequest (byte[] data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendL2CAPEchoRequest(unsigned int8[] data) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="data">The data to send.</param>
        <summary>Send an echo request over the L2CAP connection to a remote device.</summary>
        <remarks>The current implementation returns when the request has been sent, but does not indicate when
              a response is received. Also, the baseband connection must be up for the echo request to be sent.
              In the future, this method will also open the connection if necessary. The API will be updated
              to allow the client to be informed when the echo response has been received (both synchronously
              and asynchronously).</remarks>
        <exception cref="T:MonoMac.IOKit.IOKitException">If the echo request was not able to be sent.</exception>
      </Docs>
    </Member>
    <Member MemberName="ServiceClassMajor">
      <MemberSignature Language="C#" Value="public virtual MonoMac.IOBluetooth.BluetoothServiceClassMajor ServiceClassMajor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoMac.IOBluetooth.BluetoothServiceClassMajor ServiceClassMajor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoMac.Foundation.Export("serviceClassMajor")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.BluetoothServiceClassMajor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the major service class of the device.</summary>
        <value>The major service class of the device.</value>
        <remarks>This value is only meaningful if the target device has been seen during an inquiry. This can be
            by checking <see cref="P:MonoMac.IOBluetooth.IOBluetoothDevice.LastInquiryUpdate" />. If <c>null</c> is returned, then the device hasn't been seen.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Services">
      <MemberSignature Language="C#" Value="public virtual MonoMac.IOBluetooth.IOBluetoothSDPServiceRecord[] Services { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoMac.IOBluetooth.IOBluetoothSDPServiceRecord[] Services" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoMac.Foundation.Export("services")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoMac.IOBluetooth.IOBluetoothSDPServiceRecord[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an array of service records for the device.</summary>
        <value>An array of service records for the device if an SDP query has been performed. If no
            SDP query has been performed, <c>null</c> is returned.</value>
        <remarks>
          <para>The resulting array contains IOBluetoothSDPServiceRecord objects. The service records are only
            present if an SDP query has been done on the target object. This can be determined by checking
            <see cref="P:MonoMac.IOBluetooth.IOBluetoothDevice.LastServicesUpdate" />. It will return the last date/time of the SDP query. To initiate an
            SDP query on a device, use <see cref="M:MonoMac.IOBluetooth.IOBluetoothDevice.PerformSDPQuery" /></para>
          <para>Instead of allowing individual clients to query for different services and service attributes,
            the system request all of the device's services and service attributes.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSupervisionTimeout">
      <MemberSignature Language="C#" Value="public void SetSupervisionTimeout (ushort timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSupervisionTimeout(unsigned int16 timeout) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoMac.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="timeout">A client-supplied link supervision timeout value to use to monitor the connection. The timeout
              value should be specified in slots, so you can use the <see cref="M:MonoMac.IOBluetooth.IOBluetooth.GetSlotsFromSeconds(System.Double)" /> to get the proper
              value. e.g. <c>(5.0).GetSlotsFromSeconds ()</c> will give yield the proper number of slots (8000) for 5 seconds.</param>
        <summary>Sets the connection supervision timeout.</summary>
        <remarks>
        </remarks>
        <exception cref="T:MonoMac.IOKit.IOKitException">If it was not possible to set the connection supervision timeout.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
